<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Scrapy+PhantomJS+Selenium]]></title>
    <url>%2F2018%2F02%2F27%2FScrapy-PhantomJS-Selenium%2F</url>
    <content type="text"><![CDATA[很多网页具有动态加载的功能，简单的静态页面爬虫对它就无能为力了。这时候就需要PhantomJS+Selenium两大神器，再加上Scrapy爬虫框架，就可以拼凑成一个动态爬虫。 PhantomJS简单点说PhantomJS就是一个没有界面的浏览器，提供了JavaScript接口。在Windows平台，下载好PhantomJS后，将phantomjs.exe放到可执行路径里。就可以通过JS与webkit内核交互了。一个简单的例子： 12345678910111213// test.jsvar page = require('webpage').create(), //获取操作dom或web网页的对象 system = require('system'), //获取操作系统对象 address;if (system.args.length === 1) &#123; phantom.exit(1);&#125; else &#123; address = system.args[1]; page.open(address, function (status) &#123; //访问url console.log(page.content); phantom.exit(); &#125;);&#125; 在cmd中输入： 1phantomjs ./test.js http://baidu.com 就会打印出得到的html代码。 PhantomJS在linux下的安装先安装依赖包 1sudo apt-get install build-essential g++ flex bison gperf ruby perl libsqlite3-dev libfontconfig1-dev libicu-dev libfreetype6 libssl-dev libpng-dev libjpeg-dev python libx11-dev libxext-dev 下载PhantomJS 1wget https://bitbucket.org/ariya/phantomjs/downloads/phantomjs-2.1.1-linux-x86_64.tar.bz2 官方链接可能速度很慢, 百度云链接密码：g5b4.解压： 123tar -xvjf phantomjs-2.1.1-linux-x86_64.tar.bz2sudo cp -R phantomjs-2.1.1-linux-x86_64 /usr/local/share/sudo ln -sf /usr/local/share/phantomjs-2.1.1-linux-x86_64/bin/phantomjs /usr/local/bin/ SeleniumSelenium是一个自动化的测试工具，这里主要用到了它的Webdriver操作浏览器。Selenium可以操作大多数主流浏览器（可能需要相应的驱动），当然也可以操作无界面的浏览器PhantomJS。直接pip安装： 1pip install selenium 使用Selenium操作PhantomJS： 12345from selenium import webdriverdriver = webdriver.PhantomJS() # 获取浏览器对象driver.get(‘http://www.baidu.com/‘)print driver.page_source 这里的driver.get()方法会等待页面加载完成后才返回，也就是说JS也会加载完毕，有很多ajax的情况除外…Selenium还可以获取节点，填充表单，选择元素等交互操作，这些用到的时候再提。 Scrapy - Downloader MiddlewareScrapy不再详细介绍，这里主要会用到Downloader Middleware， 下载器中间件。 下载器中间件在下载器和Scrapy引擎之间，每一个request和response都会通过中间件进行处理。在中间件中，对request进行处理的函数是process_request(request, spider) process_request() 必须返回其中之一: 返回 None 、返回一个 Response 对象、返回一个 Request 对象或raise IgnoreRequest 。如果其返回 None ，Scrapy将继续处理该request，执行其他的中间件的相应方法，直到合适的下载器处理函数(download handler)被调用， 该request被执行(其response被下载)。如果其返回 Response 对象，Scrapy将不会调用 任何 其他的 process_request() 或 process_exception() 方法，或相应地下载函数； 其将返回该response。 已安装的中间件的 process_response() 方法则会在每个response返回时被调用。如果其返回 Request 对象，Scrapy则停止调用 process_request方法并重新调度返回的request。当新返回的request被执行后， 相应地中间件链将会根据下载的response被调用。 动态爬虫需要中间件处理request，将加载过特定js的页面作为response返回给spider。 融合简单说这三者的关系就是：Scrapy通过Selenium使用PhantomJS，爬取加载过JS的页面。 spider.py在自定义的spider类里，我们要控制何时使用下载器中间件(默认所有请求都会经过中间件)。例如我需要先爬取文章列表页，再获取列表页里的文章页url，再以此爬取文章详情页。在爬取列表页时，不需要经过下载器中间件执行JS，而爬取正文页就需要经过加载过JS的页面。 1234567891011121314151617181920class mySpider(Spider): name = 'myspider' start_urls = [....] def parse(self, response): """ 解析文章列表页 """ urls = response.xpath('.....') for url in urls: request = Request(url=url, callback=self.parse_post, dont_filter=True) request.meta['PhantomJS'] = True yield request def parse_post(self, response): """ 解析文章正文页 """ item = myItem() item['title'] = response.xpath('.....') 对于每一个爬取详情页的request，我们都加上了一个PhantomJS的meta： 1request.meta['PhantomJS'] = True 当请求经过下载器中间件时，检查请求中是否有这个meta，决定这个请求要不要使用中间件。 JSMiddleware.py12345678910class PhantomJSMiddleware(object): @classmethod def process_request(cls, request, spider): if request.meta.has_key('PhantomJS'): driver = webdriver.PhantomJS() driver.get(request.url) content = driver.page_source.encode('utf-8') driver.quit() return HtmlResponse(request.url, encoding='utf-8', body=content, request=request) 下载器中间件首先判断请求是否需要经过中间件，然后用PhantomJS打开请求的url，将加载好JS的页面装入HtmlResponse，返回给spider继续处理。注意：如果把爬虫添加到定时任务，需要给phantomjs指定可执行文件的路径，因为crontab不会加载用户自定义的环境变量，比如： 1driver = webdriver.PhantomJS(executable_path='/usr/local/bin/phantomjs') 另外还要在setting.py中开启中间件： 123DOWNLOADER_MIDDLEWARES = &#123; 'MySpider.middlewares.JSMiddleware.PhantomJSMiddleware': 100&#125; 改进现在的web页面内容越来越丰富，多数页面都有滚动加载之类的功能，上述爬虫只能运行加载页面完成时的JS，对其他的JS就无力了。比如某网站的文章详情页面中，图片只有在当图片区域出现在屏幕显示区域时，才会加载。对于这种情况，我们需要利用JS代码，模仿浏览器的滚动页面行为。让对应的加载图片的代码运行后，再爬取html。滚动屏幕到底部的JS函数： 123456789101112131415161718192021function scrollToBottom() &#123; var Height = document.body.clientHeight, //文本高度 screenHeight = window.innerHeight, //屏幕高度 INTERVAL = 100, // 滚动动作之间的间隔时间 delta = 500, //每次滚动距离 curScrollTop = 0; //当前window.scrollTop 值 var scroll = function () &#123; curScrollTop = document.body.scrollTop; window.scrollTo(0,curScrollTop + delta); &#125;; var timer = setInterval(function () &#123; var curHeight = curScrollTop + screenHeight; if (curHeight &gt;= Height)&#123; //滚动到页面底部时，结束滚动 clearInterval(timer); &#125; scroll(); &#125;, INTERVAL)&#125; 将上述代码放入下载器中间件中执行： 123456789101112131415161718192021js = """function scrollToBottom() &#123; ....&#125;scrollToBottom()"""class PhantomJSMiddleware(object): @classmethod def process_request(cls, request, spider): if request.meta.has_key('PhantomJS'): driver = webdriver.PhantomJS() driver.get(request.url) driver.execute_script(js) time.sleep(1) # 等待JS执行 content = driver.page_source.encode('utf-8') driver.quit() return HtmlResponse(request.url, encoding='utf-8', body=content, request=request) 测试时发现，如果等待JS执行的时间过短 1time.sleep(&lt;wait_time&gt;) 会导致爬取的页面靠近底部的图片没能加载，因为滚动函数还未执行到此处。所以需要预留一个稍微长一点的等待时间。 注明：本文转自Melw00d。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHPer 面试指南-算法篇]]></title>
    <url>%2F2018%2F02%2F22%2FPHPer-%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97-%E7%AE%97%E6%B3%95%E7%AF%87%2F</url>
    <content type="text"><![CDATA[算法可以说是大厂的必考题，对于算法，一定要理解其中的精髓、原理。 讲真，大多面试官都会问实现原理和实现的具体过程，一定要知其所以然。 冒泡排序 冒泡排序的原理：一组数据，比较相邻数据的大小，将值小数据在前面，值大的数据放在后面。 123456789101112131415161718function bubble_sort($arr) &#123; $count = count($arr); if (0 == $count) &#123; return false; &#125; for($i = 0; $i &lt; $count; $i++)&#123; for($j = 0; $j&lt; $count-1-$i; $j++)&#123; if($arr[$j] &gt; $arr[$j+1])&#123; $temp = $arr[$j]; $arr[$j] = $arr[$j+1]; $arr[$j+1] = $temp; &#125; &#125; &#125; return $arr; &#125; 这样的一个数组 array(6, 3, 8, 2, 9, 1)，排序过程是怎样的？细节问题不在过多论述，有兴趣可以从扩展阅读中寻找答案。 快速排序 快速排序是对冒泡排序的一种改进。 实现思想是：通过一趟排序将待排记录分割成独立的两部分，其中一部分的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行快速排序，整个排序过程可以递归进行，以达到整个序列有序的目的。 简单来说就是：找到当前数组中的任意一个元素（一般选择第一个元素），作为标的，新建两个空数组，遍历整个数组元素，如果遍历到的元素比当前的元素要小，那么就放到左边的数组，否则放到右面的数组，然后再对新数组进行同样的操作。 123456789101112131415161718192021222324function quick_sort($arr) &#123; $count = count($arr); if(1 &gt;= $count) &#123; return arr; &#125; $base_num = $arr[0]; //选择标的 $left_array = array();//小于标的 $right_array = array();//大于标的 for($i = 1; $i &lt; $count; $i++) &#123; if($base_num &gt; $arr[$i]) &#123; $left_array[] = $arr[$i]; &#125; else &#123; $right_array[] = $arr[$i]; &#125; &#125; //再分别对左边和右边的数组，进行相同的排序处理方式 $left_array = quick_sort($left_array); $right_array = quick_sort($right_array); //最终合并 return array_merge($left_array, array($base_num), $right_array);&#125; 二分查找（折半查找） 实现思想：将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记 录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。 12345678910111213141516171819202122function binSearch($arr, $target)&#123; $height = count($arr)-1; $low = 0; while($low &lt;= $height)&#123; $mid = floor(($low+$height)/2);//获取中间数 //两值相等，返回 if($arr[$mid] == $target)&#123; return $mid; //元素比目标大，查找左部 &#125; elseif ($arr[$mid] &lt; $target)&#123; $low = $mid + 1; //元素比目标小，查找右部 &#125; elseif ($arr[$mid] &gt; $target)&#123; $height = $mid - 1; &#125; &#125; return &quot;查找失败&quot;; &#125; 算法就简单罗列这几种，了解更多就看看扩展阅读吧。 扩展阅读 PHP 冒泡排序 php实现快速排序 PHP实现各种经典算法 PHP常见算法-面试篇 php实现二分查找法 注明：本文转自Laravel-China、無铭。]]></content>
      <categories>
        <category>Laravel</category>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Laravel</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHPer 面试指南-扩展阅读资源整理]]></title>
    <url>%2F2018%2F02%2F22%2FPHPer-%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97-%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[前端篇 收集的前端面试题和答案 前端开发面试题 史上最全的web前端面试题汇总及答案 前端工程师手册 HTTP协议：工作原理 SSL/TLS协议运行机制的概述 后端篇 3年PHPer的面试总结 垃圾回收机制 S.O.L.I.D 面向对象设计 浅谈IOC–说清楚IOC是什么 Redis和Memcached的区别 MySQL索引原理及慢查询优化 分库分表的几种常见形式 大众点评订单系统分库分表实践 MySQL 死锁问题及解决 MySQL索引背后的数据结构及算法原理 CSRF攻击与防御 XSS跨站脚本攻击 算法篇 PHP 冒泡排序 php实现快速排序 PHP实现各种经典算法 PHP常见算法-面试篇 php实现二分查找法 Linux、Git 篇 linux面试常问命令 Linux常见面试题 Git教程 Gitflow 工作流 其他 程序员简历应该怎么写？ 程序员简历模板 关于程序员生涯的思考，30 岁以后的码农们该何去何从？ 你的命运不是一头骡子 注明：本文转自Laravel-China、無铭。]]></content>
      <categories>
        <category>Laravel</category>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Laravel</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHPer 面试指南-结语：写给程序员的一些建议]]></title>
    <url>%2F2018%2F02%2F22%2FPHPer-%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97-%E7%BB%93%E8%AF%AD%EF%BC%9A%E5%86%99%E7%BB%99%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BB%BA%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[随着 IT 培训行业雨后春笋般崛起，码农的入门门槛越来越低，每年都会输出数十万码农，对于互联网整个行业来说，这是一件好事，能促进行业的整体发展，但是对于相关开发的从业者来说，程序员的竞争也越来越大。 并不是每一个人都适合软件开发，首先你要确认是否发自内心的热爱这个领域，而不是纯粹为了「高薪职业」。 即使互联网发展的再快，对于码农这个职业，一时半会也很难被取缔，这就像建筑工地的农民工一样，存在了几千年。但是随着程序员的竞争越来越大、互联网的快速发展，码农将不再有竞争优势，或许将来的有一天，码农将和现在的农民工一样，生活在社会的底层。 或许你并怎么热爱这个行业，或许你只是为了生计，但是进入了这个行业，至少可以为自己打上软件工程师的标签，而不是只会 Hello World、Control+C、Control+V 的 Coder。 就算是面向工资编程，也需要有足够的实力，而程序员该如何精进呢？ 1. 每天比别人多做一点、多学一点想必大家都听过卖油翁中的一句话：“无他，但手熟尔。” 想要在编程领域有所突破，1W 小时定律尤为体现，编程需要不断的实践，才有提高。 编程就像打篮球，不管你看再多 NBA 的视频，只有你自己去拍打篮球的时候，才能真正的去融会贯通，每天比同事多做 1 小时，坚持下去，升职加薪不再是夸夸其谈。 2. 不断学习、持续积累、坚持复盘IT 行业发展迅速，软件的版本迭代更新也非常快，而每年产生的新技术也越来越多，在这个行业中药持续不断的学习，不断更新自己的操作系统、知识体系。 在公司负责开发完项目之后，就真的完事了吗？从中遇到了那些问题？提出了那些解决方案？掌握了那些新技能？项目复盘、总结不可或缺。 3. 坚持写作说起写文章，是很多理科生的痛，不善言谈，要写作，简直比登天还难。 但是程序员非常有必要养成写作的习惯，编程和写作有很多类似的地方，最为核心的共同之处在于它们都需要清晰思考的能力。很多优秀的软件工程师也是优秀的作家，文章和代码一样富有逻辑性，行文流畅、优雅。 而且写作还可以打造个人 IP，提高个人影响力，其中最典型的就是你的技术博客，就是你的最好的简历。 4. Follow the master你现在的圈子，就决定了你将来的生活状态，也基本决定了你的技术水平，想要有所突破，就要不断的学习技术大牛们的学习方式、学习技巧，站在巨人的肩膀上，你将看的更远。 5. 坚持独立思考在软件开发流程里面，程序员只是充当一种工具，用来实现产品经理的软件标准，最终输出可交付的代码。 许多年轻的程序员勤奋工作，从早到晚一刻不停地编码，周末也来加班，努力完成公司的一个个目标，很少会去想为什么要开发这个软件？这个软件有多大的价值？更很少去想”我的人生规划是什么”？ 即使软件最终开发完毕，公司获得了利润，但是和程序员又能有多大的关联呢？谁最终能记得这个软件是你开发的呢？ 你不应该只是像工具一样工作，坚持独立思考，多规划自己的未来。 PHPer 精进之路最后在简单聊一下 PHPer 的级别，初级、中级、高级、再往上就是架构师。 简单的区分一下，初级就是指刚入门的程序员，此时的编程水平还比较稚嫩，还不足以独立开发项目的能力； 而中级就是指编程已经有了一定的火候，也积累了较多的业务经验，此时已经具备了单独开发较多项目的能力； 而高级的工程师，和中级有很大的区别，技术层面而言，最大的不同的是：中级工程师只是知其然，而不知所已然。很多技术只是会用，而且用的很熟练，但是不清楚其中的原理，在处理一些大流量、高并发的情况下，其中的差距尤为明显。 架构师呢，是一个既需要掌控整体又需要洞悉局部瓶颈，并依据具体的业务场景给出解决方案的人。到了这个职位，就不仅仅只是技术层面了，更多的还有沟通和管理。 不知道你属于哪个级别呢？是否有考虑过又该如何进阶呢？ 扩展阅读 关于程序员生涯的思考，30 岁以后的码农们该何去何从？ 你的命运不是一头骡子 注明：本文转自Laravel-China、無铭。]]></content>
      <categories>
        <category>Laravel</category>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Laravel</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHPer 面试指南-程序员如何写好一份简历？]]></title>
    <url>%2F2018%2F02%2F22%2FPHPer-%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97-%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E4%B8%80%E4%BB%BD%E7%AE%80%E5%8E%86%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[程序员的简历在求职的时候，尤为重要，简历就是销售自己的明信片，一份优秀的简历，能为你带来更多的面试机会。 我自己写了不少了简历，也指导过很多朋友写过简历，同时也看过不少程序员的简历，一份好的简历应该这么写： 简历的格式推荐使用 PDF，兼容性强且不易乱序 简历的排版要简单明了、一目了然、结构清晰 清晰罗列出个人基本信息 姓名、性别 学历、毕业院校 电话、邮箱 居住地、期望地 求职岗位、期望薪水 最好有个人博客、GitHub 地址 技术栈 工作经历 哪家公司、担任职位 起止时间 工作职责 项目经历 这个项目是什么 你负责处理了什么 结果是什么 教育经历 个人评价 工作经历、项目经历中尽量避免主观表述，少一点语义词、模糊的形容词，要用语气肯定词，一句话概述成果，一定要将自己的优势和期望明晰地表达出来。 写简历的错误姿势： 简历打开乱码，排版不整齐 个人信息不完善（还真有不写自己年龄、毕业院校的） 语气描述词太多，不够精简，看完之后完全不知所云 软件开发一两年，简历中不要有精通一词，容易被打脸 最好不要写培训经历 简历页数太多，最好不好超过 3 页 简历千万不要造假，不要造假，不要造假！ https://github.com/todayqq/resume 这是我的简历，大家可以参考一下。 写简历的神器1. 模板 https://github.com/geekcompany/ResumeSample 这份模板中包含了 PHP、iOS、Android、Java、前端等等之类的工程师简历模板，写起简历来太轻松，有木有！ 2. 在线工具 http://cv.ftqq.com/?fr=github# 在线直接编写，还可以下载、转换 PDF 文件等等。 如果你不会使用 Markdown 的话，我写了一篇 Markdown 的教程，Markdown 写作的神兵利器，你可以学习一下，Markdown 是程序员必备技能。 扩展阅读 程序员简历应该怎么写？ 面试时，如何向公司提问？ 注明：本文转自Laravel-China、無铭。]]></content>
      <categories>
        <category>Laravel</category>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Laravel</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHPer 面试指南-Linux、Git 篇]]></title>
    <url>%2F2018%2F02%2F22%2FPHPer-%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97-Linux%E3%80%81Git-%E7%AF%87%2F</url>
    <content type="text"><![CDATA[Linux 说一些常用的 Linux shell 命令 这个问题就不回答了，自由发挥 Linux 硬链接和软链接有什么区别？ 硬链接不可以跨分区，软件链可以跨分区 硬链接指向一个 i 节点，而软链接则是创建一个新的 i 节点 删除硬链接、软链接文件，对原文件都没有什么影响，但是如果删除原文件，会导致软连接失效，硬链接无影响。 建立软链接(快捷方式)，以及硬链接的命令。 软链接： ln -s slink source硬链接： ln link source 怎么利用 ps 查看指定进程的信息 ps -ef | grep pid Linux 下命令有哪几种可使用的通配符？分别代表什么含义? “？” 可替代单个字符。“*” 可替代任意多个字符。中括号“[charset]”可替代 charset 集中的任何单个字符，如[a-z]，[abABC] Git Push 代码时发生突破如何处理？ 1、使用 git stash 将本地文件暂存 2、更新代码 git pull 3、还原暂存的内容 git stash pop 线上服务器代码出了问题如何回滚？ git reset –hard HEAD^ GitFlow 中都有那些分支？ 两个长期维护分支 主分支（master） 开发分支 （develop） 三种短期分支 功能分支（feature branch） 补丁分支（hotfix branch） 预发分支（release branch） 扩展阅读 linux面试常问命令 Linux常见面试题 Git教程 Gitflow 工作流 注明：本文转自Laravel-China、無铭。]]></content>
      <categories>
        <category>Laravel</category>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Laravel</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHPer 面试指南-MySQL 篇]]></title>
    <url>%2F2018%2F02%2F22%2FPHPer-%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97-MySQL-%E7%AF%87%2F</url>
    <content type="text"><![CDATA[什么是索引，作用是什么？常见索引类型有那些？Mysql 建立索引的原则？ 索引是一种特殊的文件,它们包含着对数据表里所有记录的引用指针，相当于书本的目录。其作用就是加快数据的检索效率。常见索引类型有主键、唯一索引、复合索引、全文索引。 索引创建的原则 最左前缀原理 选择区分度高的列作为索引 尽量的扩展索引，不要新建索引 SQL 语句的优化原则？ 避免使用 Like 模糊查询 只列出需要查询的字段，而不是所有 避免使用 MySQL 函数，尽量让 MySQL 做更少的事情，减轻 MySQL 的压力 经常查询的字段，创建合适的索引，提高查询效率 什么是 MySQL 慢查询？又该如何优化？ MySQL 中查询超过指定时间的语句，被称之为「慢查询」。该如何优化呢？优化 SQL 语句，创建合适的索引，如以上两个问题。 MySQL 分库分表怎么设计 1. 垂直分表垂直分表在日常开发和设计中比较常见，通俗的说法叫做“大表拆小表”，某个表中的字段比较多，可以新建立一张“扩展表”，将不经常使用或者长度较大的字段，拆分出去放到“扩展表”中。 2. 垂直分库基本的思路就是按照业务模块来划分出不同的数据库，而不是像早期一样将所有的数据表都放到同一个数据库中。 3. 水平分表水平分表也称为横向分表，比较容易理解，就是将表中不同的数据行按照一定规律分布到不同的数据库表中（这些表保存在同一个数据库中），这样来降低单表数据量，优化查询性能。 4. 水平分库分表水平分库分表与上面讲到的水平分表的思想相同，唯一不同的就是将这些拆分出来的表保存在不同的数据库中。 什么是 MySQL 死锁？如何有效降低死锁？ 死锁：死锁一般是事务相互等待对方资源，最后形成环路，而无法继续运行。 产生死锁的原因： 系统资源不足； 进程运行推进的顺序不合适； 资源分配不当等； 如何有效降低死锁： 按同一顺序访问资源； 避免事务中的用户交互； 保持事务简短并在一个批处理中； 使用低隔离级别； 使用绑定连接； 扩展阅读 MySQL索引原理及慢查询优化 分库分表的几种常见形式 大众点评订单系统分库分表实践 MySQL 死锁问题及解决 MySQL索引背后的数据结构及算法原理 注明：本文转自Laravel-China、無铭。]]></content>
      <categories>
        <category>Laravel</category>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Laravel</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHPer 面试指南-Laravel 篇]]></title>
    <url>%2F2018%2F02%2F22%2FPHPer-%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97-Laravel-%E7%AF%87%2F</url>
    <content type="text"><![CDATA[Laravel 作为现在最流行的 PHP 框架，其中的知识较多，所以单独拿出来写一篇。 简述 Laravel 的生命周期 Laravel 采用了单一入口模式，应用的所有请求入口都是 public/index.php 文件。 注册类文件自动加载器 : Laravel通过 composer 进行依赖管理，无需开发者手动导入各种类文件，而由自动加载器自行导入。 创建服务容器：从 bootstrap/app.php 文件中取得 Laravel 应用实例 $app (服务容器) 创建 HTTP / Console 内核：传入的请求会被发送给 HTTP 内核或者 console 内核进行处理 载入服务提供者至容器：在内核引导启动的过程中最重要的动作之一就是载入服务提供者到你的应用，服务提供者负责引导启动框架的全部各种组件，例如数据库、队列、验证器以及路由组件。 分发请求：一旦应用完成引导和所有服务提供者都注册完成，Request 将会移交给路由进行分发。路由将分发请求给一个路由或控制器，同时运行路由指定的中间件 服务提供者是什么？ 服务提供者是所有 Laravel 应用程序引导启动的中心, Laravel 的核心服务器、注册服务容器绑定、事件监听、中间件、路由注册以及我们的应用程序都是由服务提供者引导启动的。 IoC 容器是什么？ IoC（Inversion of Control）译为 「控制反转」，也被叫做「依赖注入」(DI)。什么是「控制反转」？对象 A 功能依赖于对象 B，但是控制权由对象 A 来控制，控制权被颠倒，所以叫做「控制反转」，而「依赖注入」是实现 IoC 的方法，就是由 IoC 容器在运行期间，动态地将某种依赖关系注入到对象之中。 其作用简单来讲就是利用依赖关系注入的方式，把复杂的应用程序分解为互相合作的对象，从而降低解决问题的复杂度，实现应用程序代码的低耦合、高扩展。 Laravel 中的服务容器是用于管理类的依赖和执行依赖注入的工具。 Facades 是什么？ Facades（一种设计模式，通常翻译为外观模式）提供了一个”static”（静态）接口去访问注册到 IoC 容器中的类。提供了简单、易记的语法，而无需记住必须手动注入或配置的长长的类名。此外，由于对 PHP 动态方法的独特用法，也使测试起来非常容易。 Contract 是什么？ Contract（契约）是 laravel 定义框架提供的核心服务的接口。Contract 和 Facades 并没有本质意义上的区别，其作用就是使接口低耦合、更简单。 依赖注入的原理？ 这个不解释，这是理解 IoC 容器的前提。 谈谈 Laravel 和 YII 框架的区别 在 YII 框架中的路由是通过书写 Controller、Action 间接定义路由，而 Laravel 中是在 route 路由文件中直接定义路由入口 Laravel 提供 ORM 对象关系映射，使读写数据库的操作更加简单 Laravel 提供更多的 Artisan 命令和脚手架开发 Laravel 的 Composer 扩展包比 Yii 框架更多，开发更加高效 注明：本文转自Laravel-China、無铭。]]></content>
      <categories>
        <category>Laravel</category>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Laravel</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHPer 面试指南-PHP 篇]]></title>
    <url>%2F2018%2F02%2F22%2FPHPer-%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97-PHP-%E7%AF%87%2F</url>
    <content type="text"><![CDATA[PHP 篇收集了一些常见的基础、进阶面试题，基础的面试题不再作答。 基础篇 Get 和 POST 的区别 Cookie 和 Session 的区别和关系 单引号和双引号的区别 isset 和 empty 的区别 echo、print_r、print、var_dump 之间的区别 什么是 MVC？ 传值和传引用的区别？ 进阶篇 简述 S.O.L.I.D 设计原则 - - - SRP 单一职责原则 一个类有且只有一个更改的原因 OCP 开闭原则 能够不更改类而扩展类的行为 LSP 里氏替换原则 派生类可以替换基类使用 ISP 接口隔离原则 使用客户端特定的细粒度接口 DIP 依赖反转原则 依赖抽象而不是具体实现 PHP7 和 PHP5 的区别，具体多了哪些新特性？ 性能提升了两倍 增加了结合比较运算符 (&lt;=&gt;) 增加了标量类型声明、返回类型声明 try...catch 增加多条件判断，更多 Error 错误可以进行异常处理 增加了匿名类，现在支持通过new class 来实例化一个匿名类，这可以用来替代一些“用后即焚”的完整类定义 为什么 PHP7 比 PHP5 性能提升了？ 变量存储字节减小，减少内存占用，提升变量操作速度 改善数组结构，数组元素和 hash 映射表被分配在同一块内存里，降低了内存占用、提升了 cpu 缓存命中率 改进了函数的调用机制，通过优化参数传递的环节，减少了一些指令，提高执行效率 简述一下 PHP 垃圾回收机制（GC） PHP 5.3 版本之前都是采用引用计数的方式管理内存，PHP 所有的变量存在一个叫 zval 的变量容器中，当变量被引用的时候，引用计数会+1，变量引用计数变为0时，PHP 将在内存中销毁这个变量。 但是引用计数中的循环引用，引用计数不会消减为 0，就会导致内存泄露。 在 5.3 版本之后，做了这些优化： 并不是每次引用计数减少时都进入回收周期，只有根缓冲区满额后在开始垃圾回收； 可以解决循环引用问题； 可以总将内存泄露保持在一个阈值以下。 了解更多可以查看 PHP 手册，垃圾回收机制。 如何解决 PHP 内存溢出问题 增大 PHP 脚本的内存分配 变量引用之后及时销毁 将数据分批处理 Redis、Memecached 这两者有什么区别？ Redis 支持更加丰富的数据存储类型，String、Hash、List、Set 和 Sorted Set。Memcached 仅支持简单的 key-value 结构。 Memcached key-value存储比 Redis 采用 hash 结构来做 key-value 存储的内存利用率更高。 Redis 提供了事务的功能，可以保证一系列命令的原子性 Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中 Redis 只使用单核，而 Memcached 可以使用多核，所以平均每一个核上 Redis 在存储小数据时比 Memcached 性能更高。 Redis 如何实现持久化？ RDB 持久化，将 Redis 在内存中的的状态保存到硬盘中，相当于备份数据库状态。 AOF 持久化（Append-Only-File），AOF 持久化是通过保存 Redis 服务器锁执行的写状态来记录数据库的。相当于备份数据库接收到的命令，所有被写入 AOF 的命令都是以 Redis 的协议格式来保存的。 Web 安全防范 CSRF 是什么？如何防范？ CSRF（Cross-site request forgery）通常被叫做「跨站请求伪造」，可以这么理解：攻击者盗用用户身份，从而欺骗服务器，来完成攻击请求。 防范措施： 使用验证码 给每一个请求添加令牌 token 并验证 XSS 是什么？如何防范？ XSS(Cross Site Scripting)，跨站脚本攻击，攻击者往 Web 页面里插入恶意 Script 代码，当用户浏览该页之时，嵌入其中 Web 里面的 Script 代码会被执行，从而达到恶意攻击用户的目的。 防止 XSS 攻击的方式有很多，其核心的本质是：永远不要相信用户的输入数据，始终保持对用户数据的过滤。 什么是 SQL 注入？如何防范？ SQL 注入就是攻击者通过一些方式欺骗服务器，结果执行了一些不该被执行的 SQL。 SQL 注入的常见场景 数据库里被注入了大量的垃圾数据，导致服务器运行缓慢、崩溃。 利用 SQL 注入暴露了应用程序的隐私数据 防范措施： 保持对用户数据的过滤 不要使用动态拼装 SQL 增加输入验证，比如验证码 对隐私数据加密，禁止明文存储 扩展阅读 3年PHPer的面试总结 垃圾回收机制 S.O.L.I.D 面向对象设计 浅谈IOC–说清楚IOC是什么 Redis和Memcached的区别 CSRF攻击与防御 XSS跨站脚本攻击 注明：本文转自Laravel-China、無铭。]]></content>
      <categories>
        <category>Laravel</category>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Laravel</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHPer 面试指南-Web 篇]]></title>
    <url>%2F2018%2F02%2F22%2FPHPer-%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97-Web-%E7%AF%87%2F</url>
    <content type="text"><![CDATA[Web 篇的文章，PHPer 大神们可以直接略过。 对于大公司，很少会有全栈工程师这个岗位，全栈是个花哨的词，对于现在比较热门的技术，不论是 Vue 还是 Laravel，只要智商不差，看着文档，都能写出一个 CURD 来，但是这就叫全栈了吗？ 比如 Vue 中的 MVVM，其中 VM 视图的原理是什么？Laravel 为什么要这么设计？ 会用这种技术栈，其实只是学到的只是皮毛，可以会用，但是必须要有自己精通擅长的一面，一定要做到人无我有，人有我优。 面试题 谈谈对 Web 语义化的理解 语义化的含义就是用正确的标签做正确的事情，语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析，利于 SEO，也有利于代码阅读、便于维护。 简述 HTTP 协议的工作流程「重要」 地址解析;在浏览器中输入 URL，浏览器会从中分解出协议名、主机名、端口、对象路径等部分 封装 HTTP 请求数据包 浏览器获取主机 IP 地址，建立 TCP 链接（TCP 的三次握手） TCP 链接建立后发送 HTTP 请求请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和可内容。 服务器接到请求后，给予相应的响应信息其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容 服务器断开 TCP 连接 为什么使用 HTTPS？实现原理是什么？ HTTPS（超文本传输安全协议）是一种通过计算机网络进行安全通信的传输协议，提供对网站服务器的身份认证，保护数据传输的完整性、安全性。 实现过程如下： 客户端通过 TCP 和服务器建立连接之后，第一次握手的时候请求证书，服务器向客户端返回证书 客户端在收到服务端证书后，确认证书是否有效，生成对称秘钥并使用服务器的公共秘钥进行加密，然后发送给服务器。 服务器使用它的私钥对它进行解密，这样两台计算机可以开始进行对称加密进行通信。 写出一个使用 flex 布局，在 div 垂直居中的 css 代码 12345div &#123; display: flex; justify-content: center; align-items: center;&#125; 为什么把 JavaScript 文件放在 Html 底部 因为浏览器渲染 HTML 文件是从上往下渲染的，JavaScript 放在 Html 头部，会阻碍浏览器的渲染速度，增加用户的等待时间 浏览器加载 JavaScript 脚本之后会自动执行，如果放在头部，此时的 Dom 树还没有加载完，很容易出 Bug 谈谈对 JavaScript 闭包的理解 闭包是 JavaScript 函数的一种，声明即运行，可以在函数内部调用外部变量。 如何处理 Ajax 跨域问题 代理 JsonP iframe 等等…… 前端的知识比较多，一些比较基础的问题，就不再整理了，比如给 Http 常见状态码，Html5 多了那些标签，CSS 如何清除浮动等等。 如果大家有兴趣，可以阅读这些前端的常见面试题和资料。 扩展阅读 收集的前端面试题和答案 前端开发面试题 史上最全的web前端面试题汇总及答案1 前端工程师手册 HTTP协议：工作原理 SSL/TLS协议运行机制的概述 注明：本文转自Laravel-China、無铭。]]></content>
      <categories>
        <category>Laravel</category>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Laravel</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHPer 面试指南-前言]]></title>
    <url>%2F2018%2F02%2F22%2FPHPer-%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97-%E5%89%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[作为一位程序员，面试过多次，也面试过很多人，最近又在找工作，总结一下面试经验和面试题，希望可以帮到正在找工作的小伙伴们。 先说一下面试时的心态，刚入门的程序员，技术实力不高，又大多不善言谈，面试一旦遇到难题，很容易心态失衡、惊慌失措、语无伦次，最终丢掉了 Offer。 其实大可不必，心态坦然，是面试必备的一点。 面试新手，面试官心中很清楚，你的实力有几分几两，一般不会过意的为难人，就算是面试真的出了比较难的题，最多也就是要压一压，你的心理预期的薪水，或者就是考验一下你随机应变的能力。 而对于那种内心十分渴望，但是又对技术水平要求比较高的工作，你要明白，只挣自己能力范围内的薪水，对于梦寐以求的 Offer，你应该不断的提升自己的技术水平，来达到这样 Offer 的标准，而不是只是渴望、碰运气。 想要得到某样东西，最好的办法是让自己配得上它。 PHPer 的开发的技术栈大多是 LAMP 或者是 LNMP，其中 Linux、Apache（Nginx）都比较偏运维，但是 PHP、MySQL 是每一位合格的 PHPer 都必须精通的技术栈。 而 Web 开发又不单单只靠 PHP、MySQL，还需要多少的学习一下前端的知识，要精进，进阶到高级，更多的还需要了解高并发、性能优化、Web 安全相关的知识。 这次整理了不少面试相关的知识和技巧，给大家简单介绍一下纲要： Web 篇 PHP 篇 Laravel 篇 算法篇 MySQL 篇 Linux、Git 篇 程序员如何写好一份简历 结语：写给程序员的一些建议 扩展阅读资源整理 不论你是学习也好，面试也好，都要明白一点，对于技术知识，不应该向背课文一样，死记硬背，理解大于记忆。 希望大家看完之后，都能有所收获，早日找到梦寐以求的 Offer。 GitBook链接为方便大家阅读，将本 repo 同步至 GitBook：https://todayqq.gitbooks.io/phper/content/ 注明：本文转自Laravel-China、無铭。]]></content>
      <categories>
        <category>Laravel</category>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Laravel</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac环境下 mysql sql_mode 报错]]></title>
    <url>%2F2018%2F02%2F14%2Fmac%E7%8E%AF%E5%A2%83%E4%B8%8B-mysql-sql-mode-%E6%8A%A5%E9%94%99%2F</url>
    <content type="text"><![CDATA[具体出错提示： 1[Err] 1055 - Expression #1 of ORDER BY clause is not in GROUP BY clause and contains nonaggregated column &apos;information_schema.PROFILING.SEQ&apos; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by 查看sql_mode 1select @@global.sql_mode; 查询出来的值为： 1ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION 去掉ONLY_FULL_GROUP_BY，重新设置值。 1set @@global.sql_mode =&apos;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&apos;; 上面是改变了全局sql_mode，对于新建的数据库有效。对于已存在的数据库，则需要在对应的数据下执行： 1set sql_mode =&apos;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&apos;; 解决办法大致有两种：一：在sql查询语句中不需要group by的字段上使用any_value()函数这种对于已经开发了不少功能的项目不太合适，毕竟要把原来的sql都给修改一遍二：修改my.cnf（windows下是my.ini）配置文件，删掉only_full_group_by这一项若我们项目的mysql安装在ubuntu上面，找到这个文件打开一看，里面并没有sql_mode这一配置项，想删都没得删。当然，还有别的办法，打开mysql命令行，执行命令 1select @@sql_mode; 这样就可以查出sql_mode的值，复制这个值，在my.cnf中添加配置项（把查询到的值删掉only_full_group_by这个选项，其他的都复制过去）： 1sql_mode=STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION; 如果 [mysqld] 这行被注释掉的话记得要打开注释。然后重重启mysql服务注：使用命令 1set sql_mode=STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION 这样可以修改一个会话中的配置项，在其他会话中是不生效的。]]></content>
      <categories>
        <category>MYSQL</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LNMP MYSQL 启动失败]]></title>
    <url>%2F2018%2F02%2F14%2FLNMP-MYSQL-%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5%2F</url>
    <content type="text"><![CDATA[发现 公司测试服务器，最近频繁出现站点访问失败问题，站点经常显示空白页面 排查 首先就猜想是不是数据库原因，所以讲自己本地项目数据库链接改为测试服务器，发现果然本地站点也出现无法打开问题 手动重启数据库lnmp mysql restart，发现卡在重启过程中 无法成功，然后，去测试服务器查找mysql的error日志， 发现在mysql目录下并没有错误文件 打开/etc/my.cnf 发现没有配置log_error 然后增加如下配置 1log_error=/usr/local/mysql/error.log 接着重新重启数据库lnmp mysql restart，结果显而易见 还是失败，但是这次生成了 error 日志，打开日志，发现如下信息 1234567InnoDB: Completed initialization of buffer poolInnoDB: Error: log file .\\ib_logfile0 is of different size 0 5242880 bytesInnoDB: than specified in the .cnf file 0 10485760 bytes![ERROR] Plugin 'InnoDB' init function returned error.[ERROR] Plugin 'InnoDB' registration as a STORAGE ENGINE failed.[ERROR] Unknown/unsupported storage engine: INNODB[ERROR] Aborting 解决经过google 发现一个解决方案在/etc/my.cnf中 增加如下配置： 12innodb_fast_shutdown=0innodb_log_file_size=5M 然后删除/usr/local/mysql/var 文件夹下ib_logfile开头的文件 重启mysqllnmp mysql restart 发现果然成功 后记几天后发现 还是会出现问题 站点打不开删除ib_logfile开头的文件后 发现再次生成的文件大小为0猜测是不是存储空间不够 使用 df -h 命令查看 发现 果然内存不足 40G空间基本都用完了。。然后使用du -sh * 查找到之前压力测试站点生成的mongo数据库并没有删除 足足占用了 17G的内存，果断删除 并且关闭压力测试 站点入口 ，然后重启mysql lnmp mysql restart 后面果然运行正常]]></content>
      <categories>
        <category>MYSQL</category>
        <category>LNMP</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
        <tag>LNMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观察者模式的总结]]></title>
    <url>%2F2018%2F02%2F14%2F%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[什么是观察者模式观察者模式用于实现对对象进行观察：一旦主体对象状态发生改变，与之关联的观察者对象会收到通知，并进行相应操作。举个例子说明：假设一个这样的情景，当公司有一个新员工入职了，入职的当天，HR需要为他办理入职手续，网管需要给他配好电脑和办公用品，部门主管需要带他熟悉部门。传统的编程方式，就是在员工入职这个事件发生的代码之后直接加入处理逻辑,当后续我们需要增加处理逻辑时（比如员工入职后增加培训），代码会变得难以维护。这种方式是耦合的，侵入式的，增加新的逻辑需要改变事件主题的代码。运用观察者模式，将员工的入职作为事件，其他的处理逻辑都做为观察者的操作，那么，当以后需要再增加更多的逻辑时，新增逻辑代码就会很方便。具体代码实现如下。 代码实现首先定义一个观察者接口，所有的观察者都实现这个接口（为什么要定义成接口呢？因为每一个观察者的具体行为需要具体去实现，用接口定义一个统一的方法，具体的实现交给观察者去实现）1234interface observer&#123; public function update();&#125; 再定义一个事件生成器的抽象类，用来使继承它的事件都具有通知观察者的能力。1234567891011121314151617181920abstract class EventGenerator&#123; private $observers = []; //定义一个添加观察者的方法 public function addOberver(Observer $observer) &#123; $this-&gt;observers[] = $observer; &#125; //定义一个通知观察者的方法 public function notify() &#123; foreach($this-&gt;observers as $observer) &#123; $observer-&gt;update(); &#125; &#125;&#125; 然后再来定义事件类1234567891011class event extends EventGenerator&#123; //定义一个触发观察者的方法 public funtion trigger() &#123; echo "Event &lt;br/&gt;"; //开始通知观察者 $this-&gt;notify(); &#125; &#125; 开始使用12$event = new event();$event-&gt;trigger(); 这个时候，当我们要在事件发生的时候增加别的操作，只需要新增观察者就可以了新增一个观察者12345678class Observer1 implements Observer&#123; public function update() &#123; echo "操作1&lt;br/&gt;"; &#125;&#125; 然后使用的时候就是1234$event = new event();// 增加观察者$event-&gt;addObserver(new Observer1);$event-&gt;trigger(); 如果需要在事件发生后再增加操作，只需再新增相应的观察者即可。 应用观察者模式的好处观察者模式解除了主体和具体观察者的耦合，让耦合的双方都依赖于抽象，而不是依赖具体。从而使得各自的变化都不会影响另一边的变化。降低对象之间的耦合度以达到解耦的目的，符合”开闭原则”的要求。 利用 SPL 实现观察者模式PHP 通过内置的 SPL 扩展提供了对观察者模式的原生支持，其中的观察者由 3 个元素组成 ： SplObserver 接口、 SplSubject 接口和 SplObjectStorage 工具类。下面是利用 SPL 实现观察者模式的代码。SPL 的地址见这里。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class MyObserver1 implements SplObserver &#123; public function update(SplSubject $subject) &#123; echo __CLASS__ . ' - ' . $subject-&gt;getName(); &#125;&#125;class MyObserver2 implements SplObserver &#123; public function update(SplSubject $subject) &#123; echo __CLASS__ . ' - ' . $subject-&gt;getName(); &#125;&#125;class MySubject implements SplSubject &#123; private $observers; private $name; public function __construct($name) &#123; $this-&gt;observers = new SplObjectStorage(); $this-&gt;name = $name; &#125; public function attach(SplObserver $observer) &#123; $this-&gt;observers-&gt;attach($observer); &#125; public function detach(SplObserver $observer) &#123; $this-&gt;observers-&gt;detach($observer); &#125; public function notify() &#123; foreach ($this-&gt;observers as $observer) &#123; $observer-&gt;update($this); &#125; &#125; public function getName() &#123; return $this-&gt;name; &#125;&#125;$observer1 = new MyObserver1();$observer2 = new MyObserver2();$subject = new MySubject("test");$subject-&gt;attach($observer1);$subject-&gt;attach($observer2);$subject-&gt;notify();/* 输出:MyObserver1 - testMyObserver2 - test*/$subject-&gt;detach($observer2);$subject-&gt;notify();/* 输出:MyObserver1 - test*/ 注明：本文转自Laravel-China、Jeffrey00。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git命令大全]]></title>
    <url>%2F2018%2F02%2F12%2Fgit%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[git命令大全 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586git init # 初始化本地git仓库（创建新仓库）git config --global user.name "xxx" # 配置用户名git config --global user.email "xxx@xxx.com" # 配置邮件git config --global color.ui true # git status等命令自动着色git config --global color.status autogit config --global color.diff autogit config --global color.branch autogit config --global color.interactive autogit config --global --unset http.proxy # remove proxy configuration on gitgit clone git+ssh://git@192.168.53.168/VT.git # clone远程仓库git status # 查看当前版本状态（是否修改）git add xyz # 添加xyz文件至indexgit add . # 增加当前子目录下所有更改过的文件至indexgit commit -m 'xxx' # 提交git commit --amend -m 'xxx' # 合并上一次提交（用于反复修改）git commit -am 'xxx' # 将add和commit合为一步git rm xxx # 删除index中的文件git rm -r * # 递归删除git log # 显示提交日志git log -1 # 显示1行日志 -n为n行git log -5git log --stat # 显示提交日志及相关变动文件git log -p -mgit show dfb02e6e4f2f7b573337763e5c0013802e392818 # 显示某个提交的详细内容git show dfb02 # 可只用commitid的前几位git show HEAD # 显示HEAD提交日志git show HEAD^ # 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本git tag # 显示已存在的taggit tag -a v2.0 -m 'xxx' # 增加v2.0的taggit show v2.0 # 显示v2.0的日志及详细内容git log v2.0 # 显示v2.0的日志git diff # 显示所有未添加至index的变更git diff --cached # 显示所有已添加index但还未commit的变更git diff HEAD^ # 比较与上一个版本的差异git diff HEAD -- ./lib # 比较与HEAD版本lib目录的差异git diff origin/master..master # 比较远程分支master上有本地分支master上没有的git diff origin/master..master --stat # 只显示差异的文件，不显示具体内容git remote add origin git+ssh://git@192.168.53.168/VT.git # 增加远程定义（用于push/pull/fetch）git branch # 显示本地分支git branch --contains 50089 # 显示包含提交50089的分支git branch -a # 显示所有分支git branch -r # 显示所有原创分支git branch --merged # 显示所有已合并到当前分支的分支git branch --no-merged # 显示所有未合并到当前分支的分支git branch -m master master_copy # 本地分支改名git checkout -b master_copy # 从当前分支创建新分支master_copy并检出git checkout -b master master_copy # 上面的完整版git checkout features/performance # 检出已存在的features/performance分支git checkout --track hotfixes/BJVEP933 # 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支git checkout v2.0 # 检出版本v2.0git checkout -b devel origin/develop # 从远程分支develop创建新本地分支devel并检出git checkout -- README # 检出head版本的README文件（可用于修改错误回退）git merge origin/master # 合并远程master分支至当前分支git cherry-pick ff44785404a8e # 合并提交ff44785404a8e的修改git push origin master # 将当前分支push到远程master分支git push origin :hotfixes/BJVEP933 # 删除远程仓库的hotfixes/BJVEP933分支git push --tags # 把所有tag推送到远程仓库git fetch # 获取所有远程分支（不更新本地分支，另需merge）git fetch --prune # 获取所有原创分支并清除服务器上已删掉的分支git pull origin master # 获取远程分支master并merge到当前分支git mv README README2 # 重命名文件README为README2git reset --hard HEAD # 将当前版本重置为HEAD（通常用于merge失败回退）git rebasegit branch -d hotfixes/BJVEP933 # 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）git branch -D hotfixes/BJVEP933 # 强制删除分支hotfixes/BJVEP933git ls-files # 列出git index包含的文件git show-branch # 图示当前分支历史git show-branch --all # 图示所有分支历史git whatchanged # 显示提交历史对应的文件修改git revert dfb02e6e4f2f7b573337763e5c0013802e392818 # 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818git ls-tree HEAD # 内部命令：显示某个git对象git rev-parse v2.0 # 内部命令：显示某个ref对于的SHA1 HASHgit reflog # 显示所有提交，包括孤立节点git show HEAD@&#123;5&#125;git show master@&#123;yesterday&#125; # 显示master分支昨天的状态git log --pretty=format:'%h %s' --graph # 图示提交日志git show HEAD~3git show -s --pretty=raw 2be7fcb476git stash # 暂存当前修改，将所有至为HEAD状态git stash list # 查看所有暂存git stash show -p stash@&#123;0&#125; # 参考第一次暂存git stash apply stash@&#123;0&#125; # 应用第一次暂存git grep "delete from" # 文件中搜索文本“delete from”git grep -e '#define' --and -e SORT_DIRENTgit gcgit fsck]]></content>
      <categories>
        <category>GIT</category>
      </categories>
      <tags>
        <tag>GIT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 Laravel 项目中创建属于你自己的辅助方法]]></title>
    <url>%2F2018%2F02%2F12%2F%E5%9C%A8-Laravel-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%B1%9E%E4%BA%8E%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E8%BE%85%E5%8A%A9%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[这是一篇社区协同翻译的文章，已完成翻译，更多信息请点击 协同翻译介绍。 Laravel提供了许多优秀的 辅助函数 可以方便的操作数组、文件路径、字符串以及路由，比如我们爱用的dd()方法（并不。）。你可以为你的laravel应用和PHP包定义自己的辅助函数，通过Composer自动加载引入。如果你是Laravel或PHP新手，那么让我们介绍一下如何创建由Laravel自动加载的自己的辅助函数。 Laravel 应用中新建 helpers 文件第一件事是要在你的 Laravel 应用中加入 helpers 文件。helpers 文件放在哪个文件夹下，这取决于你自己的个人喜好。这边有几个建议放置 helpers 文件的路径： app/helpers.php app/Http/helpers.php 本人更倾向于： app/helpers.php。 自动加载要使用PHP辅助方法， 你需要在运行时将它们加载到程序中. 在我职业生涯的初期, 在文件顶部看到这样的代码并不少见:1require_once ROOT . '/helpers.php'; PHP 函数不能自动加载. 然而，我们有一个比使用require或require_once更好的解决方案。如果你创建了一个新的Laravel项目, 你将会在composer.json文件中看到 autoload 和 autoload-dev的健:1234567891011121314"autoload": &#123; "classmap": [ "database/seeds", "database/factories" ], "psr-4": &#123; "App\\": "app/" &#125;&#125;,"autoload-dev": &#123; "psr-4": &#123; "Tests\\": "tests/" &#125;&#125;, 如果你想添加一个helpers 文件, composer有一个 files 健 (是一个文件路径的数组) ，你可以在 autoload 中定义:123456789101112"autoload": &#123; "files": [ "app/helpers.php" ], "classmap": [ "database/seeds", "database/factories" ], "psr-4": &#123; "App\\": "app/" &#125;&#125;, 一旦你在 files 数组中添加了一个新的路径, 你需要转储自动加载器:1composer dump-autoload 现在每个需要helpers.php文件的请求将会自动加载 因为 Laravel需要在 public/index.php 中使用Composer的自动加载类:1require __DIR__.'/../vendor/autoload.php'; 定义函数在你的辅助函数类中定义函数是非常简单的，尽管有一些值得注意的地方。所有的 laravel 辅助函数都应当做函数定义冲突的检查：12345if (! function_exists('env')) &#123; function env($key, $default = null) &#123; // ... &#125;&#125; 这是很巧妙的做法，因为在当你不确定函数是否已经被定义的情况下依然可以确保程序正确运行。我更喜欢用 function_exists 来检查我的辅助函数， 但如果你是在你的应用上下文中定义辅助函数， 你 可以 不使用 function_exists 来做检查。如果跳过检查， 每当你重复定义某个辅助函数的时候都会发生冲突， 可见检查是很有用的。在实际情况中，冲突并不会像你想象的那样经常发生， 而你也应当确保你定义的函数名称不要过于常见。 你也可以为你的函数名称加上前缀以确保他们不会与其他相关函数发生冲突。 Helper Example我喜欢Rails的路径和URL辅助，当你定义一个丰富的路由时，你可以免费得到这些辅助。 例如, 一个 photos 资源路由会暴露路由的辅助方法， 就像 new_photo_path, edit_photo_path等等。当我在Laravel里用资源路由的时候，我喜欢添加一些辅助方法，这些方法在我的模板里令定义路由更佳简单。在我的实现中，我喜欢利用我定义的规则，把URL辅助方法传递给一个Eloquent模型并且拿回一个资源路由。1234create_route($model);edit_route($model);show_route($model);destroy_route($model); 这里你可能定义 show_route 在你的 app/helpers.php 文件里 (其他看起来差不多):1234567891011121314151617if (! function_exists('show_route')) &#123; function show_route($model, $resource = null) &#123; $resource = $resource ?? plural_from_model($model); return route("&#123;$resource&#125;.show", $model); &#125;&#125;if (! function_exists('plural_from_model')) &#123; function plural_from_model($model) &#123; $plural = Str::plural(class_basename($model)); return Str::kebab($plural); &#125;&#125; plural_from_model() 方法是仅仅一些可复用的代码，辅助路由的方法用这些代码来预测资源路由的基于我喜欢的命名规则的名字，这个命名规则是一个kebab-case(全小写并且分开的单词组，例如 “hello-world-hi”)模型的复数。例如，这里有一个来自模型资源名的例子:123456$model = new App\LineItem;plural_from_model($model);=&gt; line-itemsplural_from_model(new App\User);=&gt; users 用这规则来定义你的资源理由，就像 routes/web.php :12Route::resource('line-items', 'LineItemsController');Route::resource('users', 'UsersController'); 然后在你的blade模板里面，你可以做以下操作:123&lt;a href="&#123;&#123; show_route($lineItem) &#125;&#125;"&gt; &#123;&#123; $lineItem-&gt;name &#125;&#125;&lt;/a&gt; 它会生成如下的HTML:123&lt;a href="http://localhost/line-items/1"&gt; Line Item #1&lt;/a&gt; Packages你的Composer包也可以使用一个辅助文件来帮你在项目里使用任何你想要的辅助函数。你将在 composer.json 文件采用相同的方法, 定义一个 files 键在你的辅助文件的一个数组。添加function_exists() 来检查你的辅助函数是必要的，所以使用了你的代码的项目不会因命名冲突而中断。你应该选择正确的在你包里是唯一的名字，并且如果你担心的方法名太普遍，可以考虑使用短前缀。 了解更多查看 Composer的 autoloading 文档来了解更多关于引入文件,以及关于自动加载类的一些基本信息.另一个推荐的资源是学习框架中所有适用的 Laravel helpers 并且通过查看 Illuminate\Foundation helpers 和 Illuminate\Support helpers 的源码学习他们是如何工作的. 注明：本文转自Laravel-China、Summer。]]></content>
      <categories>
        <category>Laravel</category>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Laravel</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 代码简洁之道(PHP Clean Code)]]></title>
    <url>%2F2018%2F02%2F11%2FPHP-%E4%BB%A3%E7%A0%81%E7%AE%80%E6%B4%81%E4%B9%8B%E9%81%93%2F</url>
    <content type="text"><![CDATA[介绍Robert C.Martin’s 的 软件工程师准则 Clean Code 同样适用于PHP。它并不是一个编码风格指南，它指导我们用PHP写出具有可读性，可复用性且可分解的代码。并非所有的准则都必须严格遵守，甚至一些已经成为普遍的约定。这仅仅作为指导方针，其中许多都是 Clean Code 作者们多年来的经验。 灵感来自于 clean-code-javascript 尽管许多开发者依旧使用 PHP 5版本，但是这篇文章中绝大多数例子都是只能在 PHP 7.1+版本下运行。 变量使用有意义的且可读的变量名不友好的：1$ymdstr = $moment-&gt;format('y-m-d'); 友好的：1$currentDate = $moment-&gt;format('y-m-d'); 对同类型的变量使用相同的词汇不友好的：1234getUserInfo();getUserData();getUserRecord();getUserProfile(); 友好的：1getUser(); 使用可搜索的名称（第一部分）我们阅读的代码超过我们写的代码。所以我们写出的代码需要具备可读性、可搜索性，这一点非常重要。要我们去理解程序中没有名字的变量是非常头疼的。让你的变量可搜索吧！不具备可读性的代码：12// 见鬼的 448 是什么意思？$result = $serializer-&gt;serialize($data, 448); 具备可读性的：1$json = $serializer-&gt;serialize($data, JSON_UNESCAPED_SLASHES | JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE); 使用可搜索的名称（第二部分）不好的：1234// 见鬼的 4 又是什么意思？if ($user-&gt;access &amp; 4) &#123; // ...&#125; 好的方式：1234567891011class User&#123; const ACCESS_READ = 1; const ACCESS_CREATE = 2; const ACCESS_UPDATE = 4; const ACCESS_DELETE = 8;&#125;if ($user-&gt;access &amp; User::ACCESS_UPDATE) &#123; // do edit ...&#125; 使用解释性变量不好：12345$address = 'One Infinite Loop, Cupertino 95014';$cityZipCodeRegex = '/^[^,]+,\s*(.+?)\s*(\d&#123;5&#125;)$/';preg_match($cityZipCodeRegex, $address, $matches);saveCityZipCode($matches[1], $matches[2]); 一般：这个好点，但我们仍严重依赖正则表达式。123456$address = 'One Infinite Loop, Cupertino 95014';$cityZipCodeRegex = '/^[^,]+,\s*(.+?)\s*(\d&#123;5&#125;)$/';preg_match($cityZipCodeRegex, $address, $matches);[, $city, $zipCode] = $matches;saveCityZipCode($city, $zipCode); 很棒：通过命名子模式减少对正则表达式的依赖。12345$address = 'One Infinite Loop, Cupertino 95014';$cityZipCodeRegex = '/^[^,]+,\s*(?&lt;city&gt;.+?)\s*(?&lt;zipCode&gt;\d&#123;5&#125;)$/';preg_match($cityZipCodeRegex, $address, $matches);saveCityZipCode($matches['city'], $matches['zipCode']); 避免嵌套太深和提前返回 (第一部分)使用太多if else表达式会导致代码难以理解。明确优于隐式。不好：123456789101112131415161718192021function isShopOpen($day): bool&#123; if ($day) &#123; if (is_string($day)) &#123; $day = strtolower($day); if ($day === 'friday') &#123; return true; &#125; elseif ($day === 'saturday') &#123; return true; &#125; elseif ($day === 'sunday') &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125;&#125; 很棒：123456789101112function isShopOpen(string $day): bool&#123; if (empty($day)) &#123; return false; &#125; $openingDays = [ 'friday', 'saturday', 'sunday' ]; return in_array(strtolower($day), $openingDays, true);&#125; 避免嵌套太深和提前返回 (第二部分)不好：12345678910111213141516function fibonacci(int $n)&#123; if ($n &lt; 50) &#123; if ($n !== 0) &#123; if ($n !== 1) &#123; return fibonacci($n - 1) + fibonacci($n - 2); &#125; else &#123; return 1; &#125; &#125; else &#123; return 0; &#125; &#125; else &#123; return 'Not supported'; &#125;&#125; 很棒：123456789101112function fibonacci(int $n): int&#123; if ($n === 0 || $n === 1) &#123; return $n; &#125; if ($n &gt; 50) &#123; throw new \Exception('Not supported'); &#125; return fibonacci($n - 1) + fibonacci($n - 2);&#125; 避免心理映射不要迫使你的代码阅读者翻译变量的意义。明确优于隐式。不好：123456789101112$l = ['Austin', 'New York', 'San Francisco'];for ($i = 0; $i &lt; count($l); $i++) &#123; $li = $l[$i]; doStuff(); doSomeOtherStuff(); // ... // ... // ... // Wait, what is `$li` for again? dispatch($li);&#125; 很棒：12345678910$locations = ['Austin', 'New York', 'San Francisco'];foreach ($locations as $location) &#123; doStuff(); doSomeOtherStuff(); // ... // ... // ... dispatch($location);&#125; 不要增加不需要的上下文如果类名或对象名告诉你某些东西后，请不要在变量名中重复。小坏坏：12345678class Car&#123; public $carMake; public $carModel; public $carColor; //...&#125; 好的方式：12345678class Car&#123; public $make; public $model; public $color; //...&#125; 使用默认参数而不是使用短路运算或者是条件判断不好的做法：这是不太好的因为 $breweryName 可以是 NULL.1234function createMicrobrewery($breweryName = 'Hipster Brew Co.'): void&#123; // ...&#125; 还算可以的做法：这个做法比上面的更加容易理解，但是它需要很好的去控制变量的值.12345function createMicrobrewery($name = null): void&#123; $breweryName = $name ?: 'Hipster Brew Co.'; // ...&#125; 好的做法：你可以使用 类型提示 而且可以保证 $breweryName 不会为空 NULL.1234function createMicrobrewery(string $breweryName = 'Hipster Brew Co.'): void&#123; // ...&#125; 对比使用 相等运算符不好的做法：1234567$a = '42';$b = 42;使用简单的相等运算符会把字符串类型转换成数字类型if( $a != $b ) &#123; //这个条件表达式总是会通过&#125; 表达式 $a != $b会返回false但实际上它应该是true !字符串类型 ‘42’是不同于数字类型的 42好的做法：使用全等运算符会对比类型和值123if( $a !== $b ) &#123; //这个条件是通过的&#125; 表达式 $a !== $b 会返回true。 函数函数参数（2 个或更少）限制函数参数个数极其重要这样测试你的函数容易点。有超过3个可选参数会导致一个爆炸式组合增长，你会有成吨独立参数情形要测试。无参数是理想情况。1个或2个都可以，最好避免3个。再多就需要加固了。通常如果你的函数有超过两个参数，说明他要处理的事太多了。 如果必须要传入很多数据，建议封装一个高级别对象作为参数。不友好的：1234function createMenu(string $title, string $body, string $buttonText, bool $cancellable): void&#123; // ...&#125; 友好的：123456789101112131415161718class MenuConfig&#123; public $title; public $body; public $buttonText; public $cancellable = false;&#125;$config = new MenuConfig();$config-&gt;title = 'Foo';$config-&gt;body = 'Bar';$config-&gt;buttonText = 'Baz';$config-&gt;cancellable = true;function createMenu(MenuConfig $config): void&#123; // ...&#125; 函数应该只做一件事情这是迄今为止软件工程最重要的原则。函数做了超过一件事情时, 它们将变得难以编写、测试、推导。 而函数只做一件事情时，重构起来则非常简单，同时代码阅读起来也非常清晰。掌握了这个原则，你就会领先许多其他的开发者。不好的：123456789function emailClients(array $clients): void&#123; foreach ($clients as $client) &#123; $clientRecord = $db-&gt;find($client); if ($clientRecord-&gt;isActive()) &#123; email($client); &#125; &#125;&#125; 好的：1234567891011121314151617function emailClients(array $clients): void&#123; $activeClients = activeClients($clients); array_walk($activeClients, 'email');&#125;function activeClients(array $clients): array&#123; return array_filter($clients, 'isClientActive');&#125;function isClientActive(int $client): bool&#123; $clientRecord = $db-&gt;find($client); return $clientRecord-&gt;isActive();&#125; 函数的名称要说清楚它做什么不好的例子：12345678910111213class Email&#123; //... public function handle(): void &#123; mail($this-&gt;to, $this-&gt;subject, $this-&gt;body); &#125;&#125;$message = new Email(...);// What is this? A handle for the message? Are we writing to a file now?$message-&gt;handle(); 很好的例子：12345678910111213class Email &#123; //... public function send(): void &#123; mail($this-&gt;to, $this-&gt;subject, $this-&gt;body); &#125;&#125;$message = new Email(...);// Clear and obvious$message-&gt;send(); 函数只能是一个抽象级别当你有多个抽象层次时，你的函数功能通常是做太多了。 分割函数功能使得重用性和测试更加容易。不好：1234567891011121314151617181920212223function parseBetterJSAlternative(string $code): void&#123; $regexes = [ // ... ]; $statements = explode(' ', $code); $tokens = []; foreach ($regexes as $regex) &#123; foreach ($statements as $statement) &#123; // ... &#125; &#125; $ast = []; foreach ($tokens as $token) &#123; // lex... &#125; foreach ($ast as $node) &#123; // parse... &#125;&#125; 同样不是很好：我们已经完成了一些功能，但是 parseBetterJSAlternative() 功能仍然非常复杂，测试起来也比较麻烦。1234567891011121314151617181920212223242526272829303132333435function tokenize(string $code): array&#123; $regexes = [ // ... ]; $statements = explode(' ', $code); $tokens = []; foreach ($regexes as $regex) &#123; foreach ($statements as $statement) &#123; $tokens[] = /* ... */; &#125; &#125; return $tokens;&#125;function lexer(array $tokens): array&#123; $ast = []; foreach ($tokens as $token) &#123; $ast[] = /* ... */; &#125; return $ast;&#125;function parseBetterJSAlternative(string $code): void&#123; $tokens = tokenize($code); $ast = lexer($tokens); foreach ($ast as $node) &#123; // parse... &#125;&#125; 很好的：最好的解决方案是取出 parseBetterJSAlternative() 函数的依赖关系.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Tokenizer&#123; public function tokenize(string $code): array &#123; $regexes = [ // ... ]; $statements = explode(' ', $code); $tokens = []; foreach ($regexes as $regex) &#123; foreach ($statements as $statement) &#123; $tokens[] = /* ... */; &#125; &#125; return $tokens; &#125;&#125;class Lexer&#123; public function lexify(array $tokens): array &#123; $ast = []; foreach ($tokens as $token) &#123; $ast[] = /* ... */; &#125; return $ast; &#125;&#125;class BetterJSAlternative&#123; private $tokenizer; private $lexer; public function __construct(Tokenizer $tokenizer, Lexer $lexer) &#123; $this-&gt;tokenizer = $tokenizer; $this-&gt;lexer = $lexer; &#125; public function parse(string $code): void &#123; $tokens = $this-&gt;tokenizer-&gt;tokenize($code); $ast = $this-&gt;lexer-&gt;lexify($tokens); foreach ($ast as $node) &#123; // parse... &#125; &#125;&#125; 不要用标示作为函数的参数标示就是在告诉大家，这个方法里处理很多事。前面刚说过，一个函数应当只做一件事。 把不同标示的代码拆分到多个函数里。不友好的：12345678function createFile(string $name, bool $temp = false): void&#123; if ($temp) &#123; touch('./temp/'.$name); &#125; else &#123; touch($name); &#125;&#125; 友好的：123456789function createFile(string $name): void&#123; touch($name);&#125;function createTempFile(string $name): void&#123; touch('./temp/'.$name);&#125; 避免副作用一个函数应该只获取数值，然后返回另外的数值，如果在这个过程中还做了其他的事情，我们就称为副作用。副作用可能是写入一个文件，修改某些全局变量，或者意外的把你全部的钱给了陌生人。现在，你的确需要在一个程序或者场合里要有副作用，像之前的例子，你也许需要写一个文件。你需要做的是把你做这些的地方集中起来。不要用几个函数和类来写入一个特定的文件。只允许使用一个服务来单独实现。重点是避免常见陷阱比如对象间共享无结构的数据、使用可以写入任何的可变数据类型、不集中去处理这些副作用。如果你做了这些你就会比大多数程序员快乐。不好的：1234567891011121314// 这个全局变量在函数中被使用// 如果我们在别的方法中使用这个全局变量，有可能我们会不小心将其修改为数组类型$name = 'Ryan McDermott';function splitIntoFirstAndLastName(): void&#123; global $name; $name = explode(' ', $name);&#125;splitIntoFirstAndLastName();var_dump($name); // ['Ryan', 'McDermott']; 推荐的：12345678910function splitIntoFirstAndLastName(string $name): array&#123; return explode(' ', $name);&#125;$name = 'Ryan McDermott';$newName = splitIntoFirstAndLastName($name);var_dump($name); // 'Ryan McDermott';var_dump($newName); // ['Ryan', 'McDermott']; 不要定义全局函数在很多语言中定义全局函数是一个坏习惯，因为你定义的全局函数可能与其他人的函数库冲突，并且，除非在实际运用中遇到异常，否则你的API的使用者将无法觉察到这一点。接下来我们来看看一个例子：当你想有一个配置数组，你可能会写一个 config() 的全局函数，但是这样会与其他人定义的库冲突。不好的：123456function config(): array&#123; return [ 'foo' =&gt; 'bar', ]&#125; 好的：1234567891011121314class Configuration&#123; private $configuration = []; public function __construct(array $configuration) &#123; $this-&gt;configuration = $configuration; &#125; public function get(string $key): ?string &#123; return isset($this-&gt;configuration[$key]) ? $this-&gt;configuration[$key] : null; &#125;&#125; 获取配置需要先创建 Configuration 类的实例，如下：123$configuration = new Configuration([ 'foo' =&gt; 'bar',]); 现在，在你的应用中必须使用 Configuration 的实例了。 不要使用单例模式单例模式是个 反模式。 以下转述 Brian Button 的观点： 单例模式常用于 全局实例， 这么做为什么不好呢？ 因为在你的代码里 你隐藏了应用的依赖关系，而没有通过接口公开依赖关系 。避免全局的东西扩散使用是一种 代码味道. 单例模式违反了 单一责任原则： 依据的事实就是 单例模式自己控制自身的创建和生命周期. 单例模式天生就导致代码紧 耦合。这使得在许多情况下用伪造的数据 难于测试。 单例模式的状态会留存于应用的整个生命周期。 这会对测试产生第二次打击，你只能让被严令需要测试的代码运行不了收场，根本不能进行单元测试。为何？因为每一个单元测试应该彼此独立。 还有些来自 Misko Hevery 的深入思考，关于单例模式的 问题根源。不好的示范：12345678910111213141516171819202122class DBConnection&#123; private static $instance; private function __construct(string $dsn) &#123; // ... &#125; public static function getInstance(): DBConnection &#123; if (self::$instance === null) &#123; self::$instance = new self(); &#125; return self::$instance; &#125; // ...&#125;$singleton = DBConnection::getInstance(); 好的示范：123456789class DBConnection&#123; public function __construct(string $dsn) &#123; // ... &#125; // ...&#125; 用 DSN 进行配置创建的 DBConnection 类实例。1$connection = new DBConnection($dsn); 现在就必须在你的应用中使用 DBConnection 的实例了。 封装条件语句不友好的：123if ($article-&gt;state === 'published') &#123; // ...&#125; 友好的：123if ($article-&gt;isPublished()) &#123; // ...&#125; 避免用反义条件判断不友好的：123456789function isDOMNodeNotPresent(\DOMNode $node): bool&#123; // ...&#125;if (!isDOMNodeNotPresent($node))&#123; // ...&#125; 友好的：12345678function isDOMNodePresent(\DOMNode $node): bool&#123; // ...&#125;if (isDOMNodePresent($node)) &#123; // ...&#125; 避免使用条件语句这听起来像是个不可能实现的任务。 当第一次听到这个时，大部分人都会说，“没有if语句，我该怎么办？” 答案就是在很多情况下你可以使用多态性来实现同样的任务。接着第二个问题来了， “听着不错，但我为什么需要那样做？”，这个答案就是我们之前所学的干净代码概念：一个函数应该只做一件事情。如果你的类或函数有if语句，这就告诉了使用者你的类或函数干了不止一件事情。 记住，只要做一件事情。不好的：12345678910111213141516class Airplane&#123; // ... public function getCruisingAltitude(): int &#123; switch ($this-&gt;type) &#123; case '777': return $this-&gt;getMaxAltitude() - $this-&gt;getPassengerCount(); case 'Air Force One': return $this-&gt;getMaxAltitude(); case 'Cessna': return $this-&gt;getMaxAltitude() - $this-&gt;getFuelExpenditure(); &#125; &#125;&#125; 好的：123456789101112131415161718192021222324252627282930313233343536interface Airplane&#123; // ... public function getCruisingAltitude(): int;&#125;class Boeing777 implements Airplane&#123; // ... public function getCruisingAltitude(): int &#123; return $this-&gt;getMaxAltitude() - $this-&gt;getPassengerCount(); &#125;&#125;class AirForceOne implements Airplane&#123; // ... public function getCruisingAltitude(): int &#123; return $this-&gt;getMaxAltitude(); &#125;&#125;class Cessna implements Airplane&#123; // ... public function getCruisingAltitude(): int &#123; return $this-&gt;getMaxAltitude() - $this-&gt;getFuelExpenditure(); &#125;&#125; 避免类型检测 (第 1 部分)PHP 是无类型的，这意味着你的函数可以接受任何类型的参数。有时这种自由会让你感到困扰，并且他会让你自然而然的在函数中使用类型检测。有很多方法可以避免这么做。首先考虑 API 的一致性。不好的：12345678function travelToTexas($vehicle): void&#123; if ($vehicle instanceof Bicycle) &#123; $vehicle-&gt;pedalTo(new Location('texas')); &#125; elseif ($vehicle instanceof Car) &#123; $vehicle-&gt;driveTo(new Location('texas')); &#125;&#125; 好的：1234function travelToTexas(Traveler $vehicle): void&#123; $vehicle-&gt;travelTo(new Location('texas'));&#125; 避免类型检查（第 2 部分）如果你正在使用像 字符串、数值、或数组这样的基础类型，你使用的是 PHP 版本是 PHP 7+，并且你不能使用多态，但仍然觉得需要使用类型检测，这时，你应该考虑 类型定义 或 严格模式。它为您提供了标准PHP语法之上的静态类型。手动进行类型检查的问题是做这件事需要这么多的额外言辞，你所得到的虚假的『类型安全』并不能弥补丢失的可读性。保持你的代码简洁，编写良好的测试，并且拥有好的代码审查。否则，使用PHP严格的类型声明或严格模式完成所有这些工作。不好的：12345678function combine($val1, $val2): int&#123; if (!is_numeric($val1) || !is_numeric($val2)) &#123; throw new \Exception('Must be of type Number'); &#125; return $val1 + $val2;&#125; 好的：1234function combine(int $val1, int $val2): int&#123; return $val1 + $val2;&#125; 移除无用代码死代码和重复代码一样糟糕。没有理由将它保留在你的代码库中。如果它没有被任何地方调用，那么就把他除掉！如果你任然需要它，它任然安全的保留在你的历史版本中。不好的：123456789101112function oldRequestModule(string $url): void&#123; // ...&#125;function newRequestModule(string $url): void&#123; // ...&#125;$request = newRequestModule($requestUrl);inventoryTracker('apples', $request, 'www.inventory-awesome.io'); 好的：1234567function requestModule(string $url): void&#123; // ...&#125;$request = requestModule($requestUrl);inventoryTracker('apples', $request, 'www.inventory-awesome.io'); 对象和数据结构使用对象封装在 PHP 中，你可以在方法中使用关键字，如 public, protected and private。使用它们，你可以任意的控制、修改对象的属性。 当你除获取对象属性外还想做更多的操作时，你不需要修改你的代码 当 set 属性时，易于增加参数验证。 封装的内部表示。 容易在获取和设置属性时添加日志和错误处理。 继承这个类，你可以重写默认信息。 你可以延迟加载对象的属性，比如从服务器获取数据。此外，这样的方式也符合OOP开发中的开闭原则不好的：123456789class BankAccount&#123; public $balance = 1000;&#125;$bankAccount = new BankAccount();// Buy shoes...$bankAccount-&gt;balance -= 100; 好的：123456789101112131415161718192021222324252627282930313233343536class BankAccount&#123; private $balance; public function __construct(int $balance = 1000) &#123; $this-&gt;balance = $balance; &#125; public function withdraw(int $amount): void &#123; if ($amount &gt; $this-&gt;balance) &#123; throw new \Exception('Amount greater than available balance.'); &#125; $this-&gt;balance -= $amount; &#125; public function deposit(int $amount): void &#123; $this-&gt;balance += $amount; &#125; public function getBalance(): int &#123; return $this-&gt;balance; &#125;&#125;$bankAccount = new BankAccount();// Buy shoes...$bankAccount-&gt;withdraw($shoesPrice);// Get balance$balance = $bankAccount-&gt;getBalance(); 让对象拥有privat/protected属性的成员 public 公有方法和属性对于变化来说是最危险的，因为一些外部的代码可能会轻易的依赖他们，但是你没法控制那些依赖他们的代码。 类的变化对于类的所有使用者来说都是危险的。 protected 受保护的属性变化和public公有的同样危险，因为他们在子类范围内是可用的。也就是说public和protected 之间的区别仅仅在于访问机制，只有封装才能保证属性是一致的。任何在类内的变化对于所有继承子类来说都是危险的 。 private 私有属性的变化可以保证代码 只对单个类范围内的危险 (对于修改你是安全的，并且你不会有其他类似堆积木的影响 Jenga effect).因此，请默认使用 private 属性，只有当需要对外部类提供访问属性的时候才采用 public/protected 属性。更多的信息可以参考 Fabien Potencier写的针对这个专栏的文章 blog post .不好的：123456789101112class Employee&#123; public $name; public function __construct(string $name) &#123; $this-&gt;name = $name; &#125;&#125;$employee = new Employee('John Doe');echo 'Employee name: '.$employee-&gt;name; // Employee name: John Doe 好的：1234567891011121314151617class Employee&#123; private $name; public function __construct(string $name) &#123; $this-&gt;name = $name; &#125; public function getName(): string &#123; return $this-&gt;name; &#125;&#125;$employee = new Employee('John Doe');echo 'Employee name: '.$employee-&gt;getName(); // Employee name: John Doe 类组合优于继承正如 the Gang of Four 所著的 设计模式 中所说,我们应该尽量优先选择组合而不是继承的方式。使用继承和组合都有很多好处。这个准则的主要意义在于当你本能的使用继承时，试着思考一下组合是否能更好对你的需求建模。在一些情况下，是这样的。接下来你或许会想，“那我应该在什么时候使用继承？”答案依赖于你的问题，当然下面有一些何时继承比组合更好的说明： 你的继承表达了“是一个”而不是“有一个”的关系（例如人类“是”动物，而用户“有”用户详情）。 你可以复用基类的代码（人类可以像动物一样移动）。 你想通过修改基类对所有派生类做全局的修改（当动物移动时，修改它们的能量消耗）。 不好的：1234567891011121314151617181920212223242526272829303132class Employee &#123; private $name; private $email; public function __construct(string $name, string $email) &#123; $this-&gt;name = $name; $this-&gt;email = $email; &#125; // ...&#125;// 不好，因为Employees "有" taxdata// 而EmployeeTaxData不是Employee类型的class EmployeeTaxData extends Employee &#123; private $ssn; private $salary; public function __construct(string $name, string $email, string $ssn, string $salary) &#123; parent::__construct($name, $email); $this-&gt;ssn = $ssn; $this-&gt;salary = $salary; &#125; // ...&#125; 好的：123456789101112131415161718192021222324252627282930313233class EmployeeTaxData &#123; private $ssn; private $salary; public function __construct(string $ssn, string $salary) &#123; $this-&gt;ssn = $ssn; $this-&gt;salary = $salary; &#125; // ...&#125;class Employee &#123; private $name; private $email; private $taxData; public function __construct(string $name, string $email) &#123; $this-&gt;name = $name; $this-&gt;email = $email; &#125; public function setTaxData(string $ssn, string $salary) &#123; $this-&gt;taxData = new EmployeeTaxData($ssn, $salary); &#125; // ...&#125; 避免流式接口流式接口 是一种面向对象API的方法，旨在通过方法链Method chaining来提高源代码的可阅读性.流式接口虽然需要一些上下文，需要经常构建对象，但是这种模式减少了代码的冗余度 (例如： PHPUnit Mock Builder 或 Doctrine Query Builder)但是同样它也带来了很多麻烦: 破坏了封装Encapsulation 破坏了原型Decorators 难以模拟测试mock 使得多次提交的代码难以理解 更多信息可以参考 Marco Pivetta 撰写的关于这个专题的文章 blog post不好的：1234567891011121314151617181920212223242526272829303132333435363738394041class Car&#123; private $make = 'Honda'; private $model = 'Accord'; private $color = 'white'; public function setMake(string $make): self &#123; $this-&gt;make = $make; // NOTE: Returning this for chaining return $this; &#125; public function setModel(string $model): self &#123; $this-&gt;model = $model; // NOTE: Returning this for chaining return $this; &#125; public function setColor(string $color): self &#123; $this-&gt;color = $color; // NOTE: Returning this for chaining return $this; &#125; public function dump(): void &#123; var_dump($this-&gt;make, $this-&gt;model, $this-&gt;color); &#125;&#125;$car = (new Car()) -&gt;setColor('pink') -&gt;setMake('Ford') -&gt;setModel('F-150') -&gt;dump(); 好的：1234567891011121314151617181920212223242526272829303132class Car&#123; private $make = 'Honda'; private $model = 'Accord'; private $color = 'white'; public function setMake(string $make): void &#123; $this-&gt;make = $make; &#125; public function setModel(string $model): void &#123; $this-&gt;model = $model; &#125; public function setColor(string $color): void &#123; $this-&gt;color = $color; &#125; public function dump(): void &#123; var_dump($this-&gt;make, $this-&gt;model, $this-&gt;color); &#125;&#125;$car = new Car();$car-&gt;setColor('pink');$car-&gt;setMake('Ford');$car-&gt;setModel('F-150');$car-&gt;dump(); SOLIDSOLID 是 Michael Feathers 推荐的便于记忆的首字母简写，它代表了 Robert Martin 命名的最重要的五个面向对象编程设计原则： S: 职责单一原则 (SRP) O: 开闭原则 (OCP) L: 里氏替换原则 (LSP) I: 接口隔离原则 (ISP) D: 依赖反转原则 (DIP) 职责单一原则 Single Responsibility Principle (SRP)正如 Clean Code 书中所述，”修改一个类应该只为一个理由”。人们总是容易去用一堆方法 “塞满” 一个类，就好像当我们坐飞机上只能携带一个行李箱时，会把所有的东西都塞到这个箱子里。这样做带来的后果是：从逻辑上讲，这样的类不是高内聚的，并且留下了很多以后去修改它的理由。将你需要修改类的次数降低到最小很重要，这是因为，当类中有很多方法时，修改某一处，你很难知晓在整个代码库中有哪些依赖于此的模块会被影响。不好的：123456789101112131415161718192021class UserSettings&#123; private $user; public function __construct(User $user) &#123; $this-&gt;user = $user; &#125; public function changeSettings(array $settings): void &#123; if ($this-&gt;verifyCredentials()) &#123; // ... &#125; &#125; private function verifyCredentials(): bool &#123; // ... &#125;&#125; 好的：123456789101112131415161718192021222324252627282930313233class UserAuth &#123; private $user; public function __construct(User $user) &#123; $this-&gt;user = $user; &#125; public function verifyCredentials(): bool &#123; // ... &#125;&#125;class UserSettings &#123; private $user; private $auth; public function __construct(User $user) &#123; $this-&gt;user = $user; $this-&gt;auth = new UserAuth($user); &#125; public function changeSettings(array $settings): void &#123; if ($this-&gt;auth-&gt;verifyCredentials()) &#123; // ... &#125; &#125;&#125; 开闭原则 (OCP)如 Bertrand Meyer 所述, “软件实体 (类, 模块, 功能, 等) 应该对扩展开放, 但对修改关闭. “这意味着什么? 这个原则大体上是指你应该允许用户在不修改已有代码情况下添加功能.不好的：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960abstract class Adapter&#123; protected $name; public function getName(): string &#123; return $this-&gt;name; &#125;&#125;class AjaxAdapter extends Adapter&#123; public function __construct() &#123; parent::__construct(); $this-&gt;name = 'ajaxAdapter'; &#125;&#125;class NodeAdapter extends Adapter&#123; public function __construct() &#123; parent::__construct(); $this-&gt;name = 'nodeAdapter'; &#125;&#125;class HttpRequester&#123; private $adapter; public function __construct(Adapter $adapter) &#123; $this-&gt;adapter = $adapter; &#125; public function fetch(string $url): Promise &#123; $adapterName = $this-&gt;adapter-&gt;getName(); if ($adapterName === 'ajaxAdapter') &#123; return $this-&gt;makeAjaxCall($url); &#125; elseif ($adapterName === 'httpNodeAdapter') &#123; return $this-&gt;makeHttpCall($url); &#125; &#125; private function makeAjaxCall(string $url): Promise &#123; // request and return promise &#125; private function makeHttpCall(string $url): Promise &#123; // request and return promise &#125;&#125; 好的：1234567891011121314151617181920212223242526272829303132333435interface Adapter&#123; public function request(string $url): Promise;&#125;class AjaxAdapter implements Adapter&#123; public function request(string $url): Promise &#123; // request and return promise &#125;&#125;class NodeAdapter implements Adapter&#123; public function request(string $url): Promise &#123; // request and return promise &#125;&#125;class HttpRequester&#123; private $adapter; public function __construct(Adapter $adapter) &#123; $this-&gt;adapter = $adapter; &#125; public function fetch(string $url): Promise &#123; return $this-&gt;adapter-&gt;request($url); &#125;&#125; 里氏代换原则 (LSP)这是一个简单概念的可怕术语。它通常被定义为“如果S是T的一个子类型，则T型对象可以替换为S型对象”(i.e., S类型的对象可以替换T型对象)在不改变程序的任何理想属性的情况下 (正确性,任务完成度,etc.).” 这个一个更可怕的定义.这个的最佳解释是，如果你有个父类和一个子类,然后基类和子类可以互换使用而不会得到不正确的结果.这或许依然令人疑惑, 所以我们来看下经典的正方形-矩形例子。几何定义, 正方形是矩形, 但是，如果你通过继承建立了“IS-a”关系的模型，你很快就会陷入麻烦。.不好的：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Rectangle&#123; protected $width = 0; protected $height = 0; public function render(int $area): void &#123; // ... &#125; public function setWidth(int $width): void &#123; $this-&gt;width = $width; &#125; public function setHeight(int $height): void &#123; $this-&gt;height = $height; &#125; public function getArea(): int &#123; return $this-&gt;width * $this-&gt;height; &#125;&#125;class Square extends Rectangle&#123; public function setWidth(int $width): void &#123; $this-&gt;width = $this-&gt;height = $width; &#125; public function setHeight(int $height): void &#123; $this-&gt;width = $this-&gt;height = $height; &#125;&#125;/** * @param Rectangle[] $rectangles */function renderLargeRectangles(array $rectangles): void&#123; foreach ($rectangles as $rectangle) &#123; $rectangle-&gt;setWidth(4); $rectangle-&gt;setHeight(5); $area = $rectangle-&gt;getArea(); // BAD: Will return 25 for Square. Should be 20. $rectangle-&gt;render($area); &#125;&#125;$rectangles = [new Rectangle(), new Rectangle(), new Square()];renderLargeRectangles($rectangles); 好的：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455abstract class Shape&#123; abstract public function getArea(): int; public function render(int $area): void &#123; // ... &#125;&#125;class Rectangle extends Shape&#123; private $width; private $height; public function __construct(int $width, int $height) &#123; $this-&gt;width = $width; $this-&gt;height = $height; &#125; public function getArea(): int &#123; return $this-&gt;width * $this-&gt;height; &#125;&#125;class Square extends Shape&#123; private $length; public function __construct(int $length) &#123; $this-&gt;length = $length; &#125; public function getArea(): int &#123; return pow($this-&gt;length, 2); &#125;&#125;/** * @param Rectangle[] $rectangles */function renderLargeRectangles(array $rectangles): void&#123; foreach ($rectangles as $rectangle) &#123; $area = $rectangle-&gt;getArea(); $rectangle-&gt;render($area); &#125;&#125;$shapes = [new Rectangle(4, 5), new Rectangle(4, 5), new Square(5)];renderLargeRectangles($shapes); 接口隔离原则 (ISP)ISP 指出 “客户不应该被强制依赖于他们用不到的接口.”一个好的例子来观察证实此原则的是针对需要大量设置对象的类，不要求客户端设置大量的选项是有益的, 因为多数情况下他们不需要所有的设置. 使他们可选来避免产生一个“臃肿的接口”.不好的：1234567891011121314151617181920212223242526272829303132interface Employee&#123; public function work(): void; public function eat(): void;&#125;class Human implements Employee&#123; public function work(): void &#123; // ....working &#125; public function eat(): void &#123; // ...... eating in lunch break &#125;&#125;class Robot implements Employee&#123; public function work(): void &#123; //.... working much more &#125; public function eat(): void &#123; //.... robot can't eat, but it must implement this method &#125;&#125; 好的：并不是每个工人都是雇员, 但每个雇员都是工人.1234567891011121314151617181920212223242526272829303132333435interface Workable&#123; public function work(): void;&#125;interface Feedable&#123; public function eat(): void;&#125;interface Employee extends Feedable, Workable&#123;&#125;class Human implements Employee&#123; public function work(): void &#123; // ....working &#125; public function eat(): void &#123; //.... eating in lunch break &#125;&#125;// robot can only workclass Robot implements Workable&#123; public function work(): void &#123; // ....working &#125;&#125; 依赖反转原则 (DIP)这一原则规定了两项基本内容: 高级模块不应依赖于低级模块. 两者都应该依赖于抽象. 抽象类不应依赖于实例. 实例应该依赖于抽象. 一开始可能很难去理解, 但是你如果工作中使用过php框架（如Symfony）,你应该见过以依赖的形式执行这一原则依赖注入 (DI). 虽然他们不是相同的概念, DIP可以让高级模块不需要了解其低级模块的详细信息而安装它们.通过依赖注入可以做到. 这样做的一个巨大好处是减少了模块之间的耦合. 耦合是一种非常糟糕的开发模式，因为它使您的代码难以重构.不好的：123456789101112131415161718192021222324252627282930class Employee&#123; public function work(): void &#123; // ....working &#125;&#125;class Robot extends Employee&#123; public function work(): void &#123; //.... working much more &#125;&#125;class Manager&#123; private $employee; public function __construct(Employee $employee) &#123; $this-&gt;employee = $employee; &#125; public function manage(): void &#123; $this-&gt;employee-&gt;work(); &#125;&#125; 优秀的：1234567891011121314151617181920212223242526272829303132333435interface Employee&#123; public function work(): void;&#125;class Human implements Employee&#123; public function work(): void &#123; // ....working &#125;&#125;class Robot implements Employee&#123; public function work(): void &#123; //.... working much more &#125;&#125;class Manager&#123; private $employee; public function __construct(Employee $employee) &#123; $this-&gt;employee = $employee; &#125; public function manage(): void &#123; $this-&gt;employee-&gt;work(); &#125;&#125; 别写重复代码 (DRY)试着去遵循 DRY 原则。尽你最大的努力去避免复制代码，它是一种非常糟糕的行为，复制代码通常意味着当你需要变更一些逻辑时，你需要修改不止一处。试想一下，如果你在经营一家餐厅，并且你需要记录你仓库的进销记录：包括所有的土豆，洋葱，大蒜，辣椒，等等。如果你使用多个表格来管理进销记录，当你用其中一些土豆做菜时，你需要更新所有的表格。如果你只有一个列表的话就只需要更新一个地方。通常情况下你复制代码的原因可能是它们大多数都是一样的，只不过有两个或者多个略微不同的逻辑，但是由于这些区别，最终导致你写出了两个或者多个隔离的但大部分相同的方法，移除重复的代码意味着用一个 function/module/class 创建一个能处理差异的抽象。正确的抽象是非常关键的，这正是为什么你必须学习遵守在 Classes 章节展开讨论的的SOLID原则，不合理的抽象比复制代码更糟糕，所以请务必谨慎！说了这么多，如果你能设计一个合理的抽象，就去实现它！最后再说一遍，不要写重复代码，否则你会发现当你想修改一个逻辑时，你必须去修改多个地方！不好的：12345678910111213141516171819202122232425262728293031function showDeveloperList(array $developers): void&#123; foreach ($developers as $developer) &#123; $expectedSalary = $developer-&gt;calculateExpectedSalary(); $experience = $developer-&gt;getExperience(); $githubLink = $developer-&gt;getGithubLink(); $data = [ $expectedSalary, $experience, $githubLink ]; render($data); &#125;&#125;function showManagerList(array $managers): void&#123; foreach ($managers as $manager) &#123; $expectedSalary = $manager-&gt;calculateExpectedSalary(); $experience = $manager-&gt;getExperience(); $githubLink = $manager-&gt;getGithubLink(); $data = [ $expectedSalary, $experience, $githubLink ]; render($data); &#125;&#125; 好的：123456789101112131415function showList(array $employees): void&#123; foreach ($employees as $employee) &#123; $expectedSalary = $employee-&gt;calculateExpectedSalary(); $experience = $employee-&gt;getExperience(); $githubLink = $employee-&gt;getGithubLink(); $data = [ $expectedSalary, $experience, $githubLink ]; render($data); &#125;&#125; 非常好：最好让你的代码紧凑一点。12345678910function showList(array $employees): void&#123; foreach ($employees as $employee) &#123; render([ $employee-&gt;calculateExpectedSalary(), $employee-&gt;getExperience(), $employee-&gt;getGithubLink() ]); &#125;&#125; 注明：本文转自Laravel-China、Summer。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手动实现 DI 容器]]></title>
    <url>%2F2018%2F02%2F11%2F%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0-DI-%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[关于依赖注入相信大家应该都经常接触或者至少有所耳闻，比较知名的框架都支持依赖注入，比如Java的Spring，PHP的Laravel、Symfony等。现在我开始手动实现一个简陋的DI容器吧。 由开车开始先开个车，为大家举个栗子：123456789101112131415161718class Driver&#123; public function drive() &#123; $car = new Car(); echo ‘老司机正在驾驶’, $car-&gt;getCar(), PHP_EOL; &#125;&#125;class Car&#123; protected $name = ‘普通汽车’; public function getCar() &#123; return $this-&gt;name; &#125;&#125; 有两个类，Driver和Car，老司机Driver有个方法driver，在调用的时候首先得整辆车$car，然后发车。大多数同学都写过这样或者类似的代码，这样的代码单看没啥毛病，挺正常的。但是，如果我要换辆车，开普通车撩不到妹。1234class Benz extends Car&#123; protected $name = ‘奔驰’;&#125; 这时候就需要做一个比较恶心的操作了，得改老司机的代码了。（老司机：我做错了什么？换辆车还得让我重学驾照……）。因此我们需要把让Car为外界注入，将Driver和Car解耦，不是老司机自己开车的时候还得自己去造车。于是就有了下面的结果1234567891011121314class Driver&#123; protected $car; public function __construct(Car $car) &#123; $this-&gt;car = $car; &#125; public function drive() &#123; echo '老司机正在驾驶', $this-&gt;car-&gt;getCar(), PHP_EOL; &#125;&#125; 此时Driver和Car两个类已经解耦，这两个类的依赖，依靠上层代码去管理。此时，老司机会这样“开车”：123$car = new Car();$driver = new Driver($car);$driver-&gt;drive(); 此时，我们创建Driver依赖的实例，并注入。上面的例子，我们实现了依赖注入，不过是手动的，写起来感觉还是不爽。这么繁重的活怎么能手动来做呢，得让程序自己去做。于是乎，DI容器诞生。 依赖注入容器依赖注入与IoC模式类似工厂模式，是一种解决调用者和被调用者依赖耦合关系的模式。它解决了对象之间的依赖关系，使得对象只依赖IoC/DI容器，不再直接相互依赖，实现松耦合，然后在对象创建时，由IoC/DI容器将其依赖（Dependency）的对象注入（Inject）其内，这样做可以最大程度实现松耦合。依赖注入说白一点，就是容器将某个类依赖的其他类的实例注入到这个类的实例中。 这段话可能说的有点抽象，回到刚才的例子吧。刚刚我手动完成了依赖注入，比较麻烦，如果一个大型的项目这样做肯定会觉得很繁琐，而且不够优雅。因此我们需要有一位总管代替我们去干这个，这个总管就是容器。类的依赖管理全部交给容器去完成。因此，一般来说容器是一个全局的对象，大家共有的。 做一个自己的DI容器写一个功能，我们首先需要分析问题，因此我们先要明白，对于一个简单的DI容器需要哪些功能，这直接关系到我们代码的编写。对于一个简单的容器，至少需要满足以下几点： 1.创建所需类的实例2.完成依赖管理（DI）3.可以获取单例的实例4.全局唯一 综上，我们的容器类大约长这样：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Container&#123; /** * 单例 * @var Container */ protected static $instance; /** * 容器所管理的实例 * @var array */ protected $instances = []; private function __construct()&#123;&#125; private function __clone()&#123;&#125; /** * 获取单例的实例 * @param string $class * @param array ...$params * @return object */ public function singleton($class, ...$params) &#123;&#125; /** * 获取实例（每次都会创建一个新的） * @param string $class * @param array ...$params * @return object */ public function get($class, ...$params) &#123;&#125; /** * 工厂方法，创建实例，并完成依赖注入 * @param string $class * @param array $params * @return object */ protected function make($class, $params = []) &#123;&#125; /** * @return Container */ public static function getInstance() &#123; if (null === static::$instance) &#123; static::$instance = new static(); &#125; return static::$instance; &#125;&#125; 大体骨架已经确定，接下来进入最核心的make方法：1234567891011121314151617181920212223242526272829protected function make($class, $params = [])&#123; //如果不是反射类根据类名创建 $class = is_string($class) ? new ReflectionClass($class) : $class; //如果传的入参不为空，则根据入参创建实例 if (!empty($params)) &#123; return $class-&gt;newInstanceArgs($params); &#125; //获取构造方法 $constructor = $class-&gt;getConstructor(); //获取构造方法参数 $parameterClasses = $constructor ? $constructor-&gt;getParameters() : []; if (empty($parameterClasses)) &#123; //如果构造方法没有入参，直接创建 return $class-&gt;newInstance(); &#125; else &#123; //如果构造方法有入参，迭代并递归创建依赖类实例 foreach ($parameterClasses as $parameterClass) &#123; $paramClass = $parameterClass-&gt;getClass(); $params[] = $this-&gt;make($paramClass); &#125; //最后根据创建的参数创建实例，完成依赖的注入 return $class-&gt;newInstanceArgs($params); &#125;&#125; 为了容器的易用，我做了一些完善： 实现ArrayAccess接口，使单例实例可以直接通过array的方式获取，如果该实例没有，则创建 重写__get方法，更方便的获取最终版：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123class Container implements ArrayAccess&#123; /** * 单例 * @var Container */ protected static $instance; /** * 容器所管理的实例 * @var array */ protected $instances = []; private function __construct()&#123;&#125; private function __clone()&#123;&#125; /** * 获取单例的实例 * @param string $class * @param array ...$params * @return object */ public function singleton($class, ...$params) &#123; if (isset($this-&gt;instances[$class])) &#123; return $this-&gt;instances[$class]; &#125; else &#123; $this-&gt;instances[$class] = $this-&gt;make($class, $params); &#125; return $this-&gt;instances[$class]; &#125; /** * 获取实例（每次都会创建一个新的） * @param string $class * @param array ...$params * @return object */ public function get($class, ...$params) &#123; return $this-&gt;make($class, $params); &#125; /** * 工厂方法，创建实例，并完成依赖注入 * @param string $class * @param array $params * @return object */ protected function make($class, $params = []) &#123; //如果不是反射类根据类名创建 $class = is_string($class) ? new ReflectionClass($class) : $class; //如果传的入参不为空，则根据入参创建实例 if (!empty($params)) &#123; return $class-&gt;newInstanceArgs($params); &#125; //获取构造方法 $constructor = $class-&gt;getConstructor(); //获取构造方法参数 $parameterClasses = $constructor ? $constructor-&gt;getParameters() : []; if (empty($parameterClasses)) &#123; //如果构造方法没有入参，直接创建 return $class-&gt;newInstance(); &#125; else &#123; //如果构造方法有入参，迭代并递归创建依赖类实例 foreach ($parameterClasses as $parameterClass) &#123; $paramClass = $parameterClass-&gt;getClass(); $params[] = $this-&gt;make($paramClass); &#125; //最后根据创建的参数创建实例，完成依赖的注入 return $class-&gt;newInstanceArgs($params); &#125; &#125; /** * @return Container */ public static function getInstance() &#123; if (null === static::$instance) &#123; static::$instance = new static(); &#125; return static::$instance; &#125; public function __get($class) &#123; if (!isset($this-&gt;instances[$class])) &#123; $this-&gt;instances[$class] = $this-&gt;make($class); &#125; return $this-&gt;instances[$class]; &#125; public function offsetExists($offset) &#123; return isset($this-&gt;instances[$offset]); &#125; public function offsetGet($offset) &#123; if (!isset($this-&gt;instances[$offset])) &#123; $this-&gt;instances[$offset] = $this-&gt;make($offset); &#125; return $this-&gt;instances[$offset]; &#125; public function offsetSet($offset, $value) &#123; &#125; public function offsetUnset($offset) &#123; unset($this-&gt;instances[$offset]); &#125;&#125; 现在借助容器我们写一下上面的代码：1234$driver = $app-&gt;get(Driver::class);$driver-&gt;drive();//output:老司机正在驾驶普通汽车 就这么简单，老司机就能发车。这里默认注入的是Car的实例，如果需要开奔驰，那只需要这样：12345$benz = $app-&gt;get(Benz::class);$driver = $app-&gt;get(Driver::class, $benz);$driver-&gt;drive();//output:老司机正在驾驶奔驰 按照PSR-11的要求，依赖注入容器需要实现Psr\Container\ContainerInterface接口，这里只是演示并未去实现，因为那需要引入Psr依赖库，比较麻烦，其实也很简单，只是多了几个方法，有兴趣的可以自己去了解下PSR-11的要求(传送门)这里只是实现了一个非常简陋的DI容器，实际中还需要考虑很多，而且这里的容器功能上还很简陋。还有一些坑没处理，比如出现循环依赖怎么处理、延迟加载的机制……这里只是我周末闲暇练手的一点记录，大家如果有兴趣可以阅读以下Laravel或者Symfony容器那块的源码，或者了解一下Spring的容器。后续有空我也会继续完善。 注明：本文转自Laravel-China、zhengzean。]]></content>
      <categories>
        <category>Laravel</category>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx负载均衡配置]]></title>
    <url>%2F2018%2F01%2F28%2Fnginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[nginx功能强大且常用作反向代理或者负载均衡，当我们部署了一个web系统之后，面对日益增多的访问流量，采用nginx做负载均衡是一个实惠的方案，本文用来记录nginx实现负载均衡的一些操作。 实验环境 为了能够更符合真实环境，我在本机host上绑定了一个域名phantomjs.me，其ip地址为192.168.1.2，是一台安装了nginx的linux服务器，用来模拟负载均衡服务器；另外同一内网中还有3台web服务器，其ip分别是192.168.1.3，192.168.1.4，192.168.1.5。 实验目的 当我们访问phantomjs.me域名时，负载均衡服务器能够将流量负载到3台web服务器中，负载的方式可以自由选择。 方案设计 （A）192.168.1.2负载均衡服务器监听80端口，用作负载。 （B）192.168.1.3Web服务器监听80端口。 （C）192.168.1.4Web服务器监听80端口。 （D）192.168.1.5Web服务器监听80端口。 说明：A服务器作为负载均衡服务器，域名直接解析到A服务器（192.168.1.2:80）上。由A服务器将流量负载均衡到B服务器（192.168.1.3:80）、C服务器（192.168.1.4:80）和D服务器（192.168.1.5:80）上。负载均衡可以针对不同的服务器，也可以针对同一台服务器的不同端口，主要看实际需求。 nginx具体配置 编辑A服务器的nginx.conf，文件位置在nginx安装目录下，一般在/etc/nginx/nginx.conf。在http段加入以下代码： 12345678910111213141516upstream server_pools&#123; server 192.168.1.3:80; #分别对应三台web服务器 server 192.168.1.4:80; server 192.168.1.5:80;&#125;server&#123; listen 80; #nginx开启的端口 server_name phantoms.me; #测试域名 location / &#123; proxy_pass http://phantomjs.me; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; access_log /var/log/nginx.log; #添加日志记录&#125; 重启nginx1/etc/init.d/nginx restart 最后访问http://phantomjs.me server中可用的参数默认upstream server后的参数 weight=1 max_fails=1 fail_timeout=10s。 weight：服务器权重 max_fails=number:最大失败尝试次数 fail_timeout=time:设置服务器不可用的时长 backup：备用主机 down：手动标记不再处理任何用户请求 Nginx负载均衡的4种方案配置实例1、轮询轮询即Round Robin，根据Nginx配置文件中的顺序，依次把客户端的Web请求分发到不同的后端服务器。配置的例子如下：12345678910111213http&#123; upstream sampleapp &#123; server &lt;&lt;dns entry or IP Address(optional with port)&gt;&gt;; server &lt;&lt;another dns entry or IP Address(optional with port)&gt;&gt;; &#125; .... server&#123; listen 80; ... location / &#123; proxy_pass http://sampleapp; &#125; &#125; 2、最少连接 Web请求会被转发到连接数最少的服务器上。 配置的例子如下： 1234567891011121314http&#123; upstream sampleapp &#123; least_conn; server &lt;&lt;dns entry or IP Address(optional with port)&gt;&gt;; server &lt;&lt;another dns entry or IP Address(optional with port)&gt;&gt;; &#125; .... server&#123; listen 80; ... location / &#123; proxy_pass http://sampleapp; &#125; &#125; 3、IP地址哈希 前述的两种负载均衡方案中，同一客户端连续的Web请求可能会被分发到不同的后端服务器进行处理，因此如果涉及到会话Session，那么会话会比较复杂。 常见的是基于数据库的会话持久化。要克服上面的难题，可以使用基于IP地址哈希的负载均衡方案。这样的话，同一客户端连续的Web请求都会被分发到同一服务器进行处理。 配置的例子如下： 1234567891011121314http&#123; upstream sampleapp &#123; ip_hash; server &lt;&lt;dns entry or IP Address(optional with port)&gt;&gt;; server &lt;&lt;another dns entry or IP Address(optional with port)&gt;&gt;; &#125; .... server&#123; listen 80; ... location / &#123; proxy_pass http://sampleapp; &#125; &#125; 4、基于权重的负载均衡 基于权重的负载均衡即Weighted Load Balancing，这种方式下，我们可以配置Nginx把请求更多地分发到高配置的后端服务器上，把相对较少的请求分发到低配服务器。 配置的例子如下： 12345678910111213http&#123; upstream sampleapp &#123; server &lt;&lt;dns entry or IP Address(optional with port)&gt;&gt; weight=2; server &lt;&lt;another dns entry or IP Address(optional with port)&gt;&gt;; &#125; .... server&#123; listen 80; ... location / &#123; proxy_pass http://sampleapp; &#125; &#125; 上面的例子在服务器地址和端口后weight=2的配置，这意味着，每接收到3个请求，前2个请求会被分发到第一个服务器，第3个请求会分发到第二个服务器，其它的配置同轮询配置。还要说明一点，基于权重的负载均衡和基于IP地址哈希的负载均衡可以组合在一起使用。 nginx反向代理这里顺便记录一下，用nginx配置反向代理的方法，这种方法也被大量用在网页劫持（黑产）中，这里不详细介绍了。 配置将以下内容添加到nginx配置文件的server中： 123location /update/&#123;#将本地update目录代理到baidu.com/update目录下，即访问本地update其实是在访问baidu的update。 proxy_pass http://baidu.com/update; &#125; 重启nginx，尝试访问http://phantomjs.me/update/其实际获取的是baidu的update目录资源。 关于nginx负载均衡更详细的内容，可以访问：http://www.jusene.me/2017/05/24/nginx-proxy/ 注明：本文转自nMask’s Blog。]]></content>
      <categories>
        <category>NGINX</category>
      </categories>
      <tags>
        <tag>NGINX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[session的原理总结]]></title>
    <url>%2F2018%2F01%2F27%2Fsession%E7%9A%84%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[之前在学校的时候，只知道session与cookie的区别在于：session是保存在服务器端，cookie保存在客户端。session怎么样保存的？以文件的形式保存。自己去测试过。有的忘记了。对应session的id号模糊不清。在开发中，非常有必要弄明白具体细节。不能停留在使用session_start()函数了，然后获取session值。不知道里面的机制，在开发中遇到了新的问题，解决起来比较费心。 一、session是怎么保存的？怎么去查看其内容？session是以文件的形式保存的。php.ini中有个配置项–session.savepath= “”;这个里面填写的路径，将会使session文件保存在该路径下。session文件的命名格式是：”sess[PHPSESSID的值]”。每一个文件，里面保存了一个会话的数据。其实只要使用代码$_SESSION[‘user_id’] = $value;就会促发php的session机制，结果往对应的session文件中写入一个值。 二、session.save_path路径下这么多的session文件，php是如何确定要调用哪个session文件的？php是依据，一个名为PHPSESSID的cookie，根据它的值，确定要调用哪个session文件的。去浏览器中，可以看到一个cookie名为PHPSESSID，假如它的值为”sess_adbjsf2q1ass26oootd163sf84”，那么，当访问服务器的时候，就会调用session目录下名为”sess_adbjsf2q1ass26oootd163sf84”的文件。其实，PHPSESSID就是一个会话id，以此来确定，哪个是你的会话数据。 以下是在浏览器查看cookie所看到的cookie的名字PHPSESSID是可以改的，在php.ini中 session.name = PHPSESSID就是设置该cookie的名字。结合自己实际开发中遇到的问题，总结一下：要说session跟cookie有关联的地方，就是跟PHPSESSID这个cookie有绑定关系。其他，不管你设置什么cookie，使用session的时候是不会用到这些值的。也无法获取到。比如同步登陆，设置即使设置了cookie，而你的应用是依据session判断是否为登陆状态的(事实上也必须如此，因为session保存在服务器端，安全性更高，哪个依据cookie认为你已经登陆，那么很惨)。所以，这样的情况就会出现，即使成功设置了cookie。也还是不能同步登陆。 三、经常遇到的现象：为什么删除一个session文件，之后生成一个session文件，新的文件名字还是与原来一样？理解到session文件的命名规则是：“sess_PHPSESSID值“。那么，就很容易明白了。因为，客户端存在cookie：PHPSESSID。客户端发送请求后，会将该cookie发送给服务器(php可以使用$_COOKIE[‘PHPSESSID’]看到其内容)，这样的话，还是会根据PHPSESSID生成一个session文件的。 四、如何查看session文件中的session值？我在开发中发现，如果仅仅依靠session_start()和$_SESSION[‘user_id’]这样的代码，去调试，还不够全面的了解问题所在。比如，我想知道，session_start()到底在完成哪些操作？如果，想动态，实时知道session的值是如何被改写的，打开一个session文件，查看是很了然的。原来，里面就是保存的是一些被序列化后的值。也明白一个知识点，”php圣经”中讲解session的时候，提到session值做被序列化了。下面看到的session内容就是被序列化了。打开一个session文件，内容如下：cityID|i:0;cityName|s:3:”all”;fanwe_lang|s:5:”zh-cn”;fanwe_currency|a:4:{s:2:”id”;s:1:”1”;s:6:”name_1”;s:9:”人民币”;s:4:”unit”;s:3:”￥”;s:5:”radio”;s:6:”1.0000”;}_fanwe_hash__|s:32:”77c18770c6cb5d89444c407aaa3e8477”; 总结出读取规则：1、每一个session的值是以分号”;”分开的。比如“cityID|i:0;cityName|s:3:”all”;”就是一个完整的session值结束2、里面的读取规则：符号“|”前面表示session名称。符号后面是该session的具体信息。包括：数据类型，字符长度，内容。上面第一个就相当于使用如下php代码访问:$_SESSION[‘cityID’]后面的s表示数据值的长度，3表示字符长度。比如这一段：fanwe_lang|s:5:”zh-cn”; fanwe_lang是变量的名称，变量值是”zh-cn”,长度刚好是5，就是”s:5“标明的。最后”all”就表示session的具体值了。就是使用代码$_SESSION[‘cityID’]后会得到的结果。3.一个session可以保存一个数组。符号{}表示数组的内容。上面的花括号{}是$_SESSION[‘fanwe_currency’]所保存的内容。要想查看id的值，就使用代码：$_SESSION[‘fanwe_currency’][‘id’] 五、怎么样理解session_start等函数所做的实际操作是什么？我是这样理解的：session_start，可以看成是创建一个session文件。假如有原来的session文件，或许没有创建。引入一个。往session文件中写值，那是代码“$_SESSION[‘’]=” “; 赋值所完成的操作。sessionstart()生成一个新的session文件名时。会判断是否存在cookie名为PHPSESSID的值。如果存在，那么就会按照它的值，组合成一个文件名”sess[phpcookie值]”。所以，在目录下，老是能够看到之前删除过的session文件名。如果将浏览器中对应的cookie(PHPSESSID)删掉。那么就不会生成同样的名字了。如果不存在名为PHPSESSID的cookie。php所做的估计为：先发送一个cookie，然后按照cookie的值生成一个(我可以在浏览器中马上看到一个名为PHPSESSID的cookie) 其实，现在也更加深刻地理解了一个知识：在调用session_start()之前不能有任何输出。有输出就会报错。session_start()已经封装了发送cookie的操作(发送一个名称为PHPSESSID的cookie到浏览器)。涉及到http的一个原理:头部信息必须在内容之前发送才行。所以，使用echo ‘内容’;header(‘Content-type: text/xml; charset=gb2312’);//头部信息，不算内容 可以这样认为：session_start()内部已经进行了一次发送头部动作。所以之前不能有任何输出内容。手册中的英文大致是这样说的：创建一个session，或者恢复当前一个session(基于request请求传递的session id,这里应该值的就是http请求时传递的名为PHPSESSID的cookie) 实际开发应用总结：只要是同一个用户的操作。导航程序访问记录和团购程序访问的记录都是保存在同一个session文件中如果是不同的域呢？假如用户访问cs.test.com和daohang.test.com，两方程序都设置了session。那么session的结果保存在同一个session文件中吗？因为：服务器是统一管理session文件的存放的。而php引擎是根据phpsessionid的值确定要操作哪个session文件。session文件名的格式是：”sess_[phpcookie值]”。依次寻找对应的session文件(于是在浏览器查看名为PHPSESSIONID的cookie，过期时间是在会话结束后)所以，只要cs.test.com和daohang.test.com使用的是同一台服务器。这样的话，假如是多台服务器的情况。那么就不得不将session保存在数据库中去。这样实现session共享。跟具体的服务器是无关的。（2013年更新：实际上共享session不局限于数据库中保存，关于session共享方案，根据自己的理解一年后写了一篇总结文章，http://www.cnblogs.com/wangtao_20/p/3395518.html）session文件是某个用户整个会话过程中数据。那么，假如cs.test.com和daohang.test.com下的两个程序运行在同一个服务器上。就意味着，访问cs.test.com与访问daohang.test.com是同一个会话。也就意味着，这两边访问后设置的session数据是保存在同一个session文件中的。可以将名为PHPSESSIONID的cookie，其值看成是一个会话的id。会话结束后，该cookie过期或者被删。那么，服务器对应的session文件(名为”sess_[phpcookie值]”)会被删掉吗？查看发现并不会被删掉。所以才会有session文件很多，出现读取性能的问题。session文件比较多的情况下，产生I/Q读写性能问题。了解到可以将session文件分多个目录保存(参考http://www.jb51.net/article/27941.htm)。php.ini中的配置项session.save_path,前面一个值M可以指定目录的深度级别。这个没测试过。需要用到的时候，再去测试一下。 待解决疑问一、session的过期时间是怎么确定的？查看session文件内容，发现里面有个值设置了session文件的过期时间：__HTTP_Session_Expire_TS|i:1297750868;已掌握的信息：PHPSESSID该cookie的过期时间在浏览器中显示：会话结束后过期所有的session文件没有被自动删掉，只是有个过期时间，以此决定：是新生成一个session文件还是使用原来的。原来：服务器定期session清理机制估计会用到这个东西 二、如果没有设置php.ini中的参数。php默认会将session文件保存到什么位置？[服务端]1234567891011121314151617session.save_handler = files默认为file，定义session在服务端的保存方式，file意为把sesion保存到一个临时文件里，如果我们想自定义别的方式保存（比如用数据库），则需要把该项设置为user；session.save_path = "D:/APMServ5.2.0/PHP/sessiondata/"定义服务端存储session的临时文件的位置。session.auto_start = 0如置1，则不用在每个文件里写session_start(); session自动start ：）session.gc_probability = 1session.gc_divisor = 100session.gc_maxlifetime = 1440这三个配置组合构建服务端session的垃圾回收机制session.gc_probability与session.gc_divisor构成执行session清理的概率，理论上的解释为服务端定期有一定的概率调用gc函数来对session进行清理，清理的概率为：gc_probability/gc_divisor 比如：1/100 表示每一个新会话初始化时，有1%的概率会启动垃圾回收程序，清理的标准为session.gc_maxlifetime定义的时间。 [客户端]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748session.use_cookies = 1sessionid在客户端采用的存储方式，置1代表使用cookie记录客户端的sessionid，同时，$_COOKIE变量里才会有$_COOKIE[‘PHPSESSIONID’]这个元素存在；session.use_only_cookies = 1也是定义sessionid在客户端采用的存储方式，置1代表仅仅使用 cookie 来存放会话 ID。一般来说，现在客户端都会支持cookie，所以建议设置成1，这样可以防止有关通过 URL 传递会话 ID 的攻击。session.use_trans_sid = 0相对应于上面那个设置，这里如果置1，则代表允许sessionid通过url参数传递，同理，建议设置成0；session.referer_check = 这个设置在session.use_trans_sid = 1的时候才会生效，目的是检查HTTP头中的"Referer"以判断包含于URL中的会话id是否有效，HTTP_REFERER必须包含这个参数指定的字符串，否则URL中的会话id将被视为无效。所以一般默认为空，即不检查。 session.name = PHPSESSID定义sessionid的名称，即变量名，所以通过浏览器http工具看到的http头文件里的PHPSESSID=##############；session.hash_function = 0选择session_name的加密方式，0代表md5加密，1代表sha1加密，默认是0，但是据说用sha1方式加密，安全性更高；session.hash_bits_per_character = 4指定在session_name字符串中的每个字符内保存多少位二进制数，这些二进制数是hash函数的运算结果。4 bits: 0-9, a-f 5 bits: 0-9, a-v 6 bits: 0-9, a-z, A-Z, "-", "," url_rewriter.tags = "a=href,area=href,frame=src,input=src,form=,fieldset="指定重写哪些HTML标签来包含sid(session_id)（仅在"session.use_trans_sid"打开的情况下有效），URL重写器将添加一个隐藏的"&lt;input&gt;"，它包含了本应当额外追加到URL上的信息。 session.cookie_lifetime = 0保存sessionid的cookie文件的生命周期，如置0，代表会话结束，则sessionid就自动消失，常见的强行关闭浏览器，就会丢失上一次的sessionid；session.cookie_path = /保存sessionid的cookie文件在客户端的位置；session.cookie_domain = /保存sessionid的cookie的域名设置，这跟cookie允许的域名的访问权限设置有关，一般来说想让自己网站所有的目录都能访问到客户端的cookie，就应该设置成“/”如需要详细了解，可以看下setcookie()函数的domain参数相关设置和使用方法；session.bug_compat_42 = 1session.bug_compat_warn = 1这两个可以说几乎是快要被废弃的设置，是为了老版本的php服务的，主要是针对 session_register函数，因为php5的register_global默认是关闭状态，所以在php5里根本用不到 session_register这个函数；并且php6就要废除这个设置，直接定义为关闭，所以没必要研究这两个了； 2015.6.14 今天无意中看php手册，注意到这句话：在某些操作系统上，建议使用可以高效处理大量小尺寸文件的文件系统上的路径来保存会话数据。例如，在 Linux 平台上，对于会话数据保存的工作而言，reiserfs 文件系统会比 ext2fs 文件系统能够提供更好的性能。这个是好的方向。session的数据一般很小。适合小文件的文件系统来使用，而我们的传统的文件系统不太适合。 注明：本文转自CNBLOG。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MYSQL事务四大特性与隔离级别]]></title>
    <url>%2F2018%2F01%2F26%2FMYSQL%E4%BA%8B%E5%8A%A1%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%2F</url>
    <content type="text"><![CDATA[什么是事务在一个商城系统中，用户购买商品操作操作MYSQL，一般都需要减少库存以及减少用户金额等，至少需要两条语句来进行操作，而一旦某个流程执行SQL时发生错误，就会导致剩下语句没有执行，数据发生错误。这时候就可以使用事务来进行操作。事务就是一组原子性的SQL查询，或者说一个独立的工作单元，假如事务中某一条语句错误，那么所有语句都不会执行，这样事务内的语句就只有一个结果，要么成功，要么失败。 事务的四大特性事务具有四大特性： 原子性：一个事务被视为一个最小的工作单元，整个事务只有两个结果，要么成功，要么失败。 一致性：一致性是指事务必须使数据库从一个一致的状态变到另外一个一致的状态，也就是执行事务之前和之后的状态都必须处于一致的状态。 隔离性：隔离性是指并发的事务是相互隔离的。即一个事务内部的操作及正在操作的数据必须封锁起来，在最终提交以前，对其他事务是不可见的。 持久性：持久性是指一个事务一旦被提交了，那么对于数据库中的数据改变就是永久性的，即便是在数据库系统遭遇到故障的情况下也不会丢失提交事务的操作。 事务的四种隔离级别在数据库操作中，为了有效保证并发读取数据的正确性，提出的事务隔离级别。我们的数据库锁，也是为了构建这些隔离级别存在的。 未提交读(Read uncommitted)：允许脏读，就是一个事务可以读取另一个未提交事务的数据。 已提交读(Read committed): 读提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。 可重复读(Repeatable read): 可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读 可串行化(Serializable): 在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下 大多数数据库默认的事务隔离级别是Read committed，比如Sql Server , Oracle。MySQL的默认隔离级别是Repeatable read]]></content>
      <categories>
        <category>MYSQL</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十个 Laravel 5 程序优化技巧]]></title>
    <url>%2F2018%2F01%2F26%2F%E5%8D%81%E4%B8%AA-Laravel-5-%E7%A8%8B%E5%BA%8F%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[说明性能一直是 Laravel 框架为人诟病的一个点，所以调优 Laravel 程序算是一个必学的技能。接下来分享一些开发的最佳实践，还有调优技巧，大家有别的建议也欢迎留言讨论。这里是简单的列表： 12345678910配置信息缓存 artisan config:cache路由缓存 artisan route:cache类映射加载优化 artisan optimize自动加载优化 composer dumpautoload使用 Memcached 来存储会话 config/session.php使用专业缓存驱动器 config/cache.php数据库请求优化为数据集书写缓存逻辑使用即时编译器（JIT），如：HHVM、OpCache前端资源合并 Elixir 1. 配置信息缓存使用以下 Artisan 自带命令，把 config 文件夹里所有配置信息合并到一个文件里，减少运行时文件的载入数量：1php artisan config:cache 上面命令会生成文件 bootstrap/cache/config.php，可以使用以下命令来取消配置信息缓存：1php artisan config:clear 此命令做的事情就是把 bootstrap/cache/config.php 文件删除。 注意：配置信息缓存不会随着更新而自动重载，所以，开发时候建议关闭配置信息缓存，一般在生产环境中使用，可以配合 Envoy 任务运行器 一起使用。 2. 路由缓存路由缓存可以有效的提高路由器的注册效率，在大型应用程序中效果越加明显，可以使用以下命令：1php artisan route:cache 以上命令会生成 bootstrap/cache/routes.php 文件，需要注意的是，路由缓存不支持路由匿名函数编写逻辑，详见：文档 - 路由缓存。可以使用下面命令清除路由缓存：1php artisan route:clear 此命令做的事情就是把 bootstrap/cache/routes.php 文件删除。 注意：路由缓存不会随着更新而自动重载，所以，开发时候建议关闭路由缓存，一般在生产环境中使用，可以配合 Envoy 任务运行器 一起使用。 3. 类映射加载优化optimize 命令把常用加载的类合并到一个文件里，通过减少文件的加载，来提高运行效率：1php artisan optimize --force 会生成 bootstrap/cache/compiled.php 和 bootstrap/cache/services.json 两个文件。你可以可以通过修改 config/compile.php 文件来添加要合并的类。在 production 环境中，参数 –force 不需要指定，文件就会自动生成。要清除类映射加载优化，请运行以下命令：1php artisan clear-compiled 此命令会删除上面 optimize 生成的两个文件。 注意：此命令要运行在 php artisan config:cache 后，因为 optimize 命令是根据配置信息（如：config/app.php 文件的 providers 数组）来生成文件的。 4. 自动加载优化此命令不止针对于 Laravel 程序，适用于所有使用 composer 来构建的程序。此命令会把 PSR-0 和 PSR-4 转换为一个类映射表，来提高类的加载速度。1composer dumpautoload -o 注意：php artisan optimize –force 命令里已经做了这个操作。 5. 使用 Memcached 来存储会话每一个 Laravel 的请求，都会产生会话，修改会话的存储方式能有效提高程序效率，会话的配置信息是 config/session.php，建议修改为 Memcached 或者 Redis 等专业的缓存软件：1'driver' =&gt; 'memcached', 6. 使用专业缓存驱动器「缓存」是提高应用程序运行效率的法宝之一，默认缓存驱动是 file 文件缓存，建议切换到专业的缓存系统，如 Redis 或者 Memcached，不建议使用数据库缓存。1'default' =&gt; 'redis', 7. 数据库请求优化数据关联模型读取时使用 延迟预加载 和 预加载 ；使用 Laravel Debugbar 或者 Clockwork 留意每一个页面的总数据库请求数量；这里的篇幅只写到与 Laravel 相关的，其他关于数据优化的内容，请自行查阅其他资料。 8. 为数据集书写缓存逻辑合理的使用 Laravel 提供的缓存层操作，把从数据库里面拿出来的数据集合进行缓存，减少数据库的压力，运行在内存上的专业缓存软件对数据的读取也远远快于数据库。12345$posts = Cache::remember('index.posts', $minutes = 30, function()&#123; return Post::with('comments', 'tags', 'author', 'seo')-&gt;whereHidden(0)-&gt;get();&#125;);remember 甚至连数据关联模型也都一并缓存了，多么方便呀。 9. 使用即时编译器HHVM 和 OpCache 都能轻轻松松的让你的应用程序在不用做任何修改的情况下，直接提高 50% 或者更高的性能，PHPhub 之前做个一个实验，具体请见：使用 OpCache 提升 PHP 5.5+ 程序性能。 10. 前端资源合并作为优化的标准，一个页面只应该加载一个 CSS 和 一个 JS 文件，并且文件要能方便走 CDN，需要文件名随着修改而变化。 Laravel Elixir 提供了一套简便实用的方案，详细请见文档：Laravel Elixir 文档。 注明：本文转自Laravel-China、Summer。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个 16年毕业生所经历的 PHP 面试]]></title>
    <url>%2F2018%2F01%2F26%2F%E4%B8%80%E4%B8%AA-16%E5%B9%B4%E6%AF%95%E4%B8%9A%E7%94%9F%E6%89%80%E7%BB%8F%E5%8E%86%E7%9A%84-PHP-%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[前言：有收获的话请加颗小星星，没有收获的话可以 反对 没有帮助 举报三连 有心的同学应该会看到我这个noteBook下面的其它知识，希望对你们有些许帮助。 本文地址 时间点：2017-11 一个16年毕业生所经历的php面试 一、什么是面试 二、面试准备 1. 问：什么时候开始准备？ 2. 问：怎么准备？ 三、面试干货 1、某教育机构两面 mysql事务是什么 php代码解释过程 百度统计的实现原理 如何共享session git分支管理策略 restful设计 附加题：论坛的表设计 情景题：一个登录系统的改进 自己最满意的代码 了解哪些设计模式，实际用例 2、某电商公司三人面 将一个二维数组的值首字母大写 使用正则获取html里的href属性的值和a标签内的值，并以href值为key，a标签内的值为value存入二维数组中 优化语句查询 找出N个数中的第M大的数 Ajax跨域请求时，会出现什么问题？如何解决 如何优化一个CPU运算密集的网站 自己最满意的 代码 其它 3、某民宿杭州分公司一面 phpunit的用法 redis异步队列实现细节 redis中zest如何根据两个属性排序，比如id和age 你对多进程和多线程还有协程的理解 说说怎么理解现在前端框架中的组件化和模块化 http协议中get和post的区别，怎么实现的 最近在看什么书 4、某众筹杭州分公司三面 php使用什么mysql连接？ 场景题：索引的建立规则和explain 你用的是php版本是哪个？为什么？php7有什么更新？ nginx相关 看你用过laravel和tp，比较下两款框架 你未来的发展规划，1年的，3年的 其他 5、某旅游公司两面 为什么离职 如何选择PHP的？关于目前流行的Java比较？ 有没有系统的培训过？有没有看php相关的网络课程和书籍？ 看你用过laravel和tp， 比较下两款框架 php基础知识** laravel包** 你未来的发展规划， 1年的，3年的 你可以问我两个问题？ 其 他 四、面试总结 一、什么是面试说到面试，还是先说你为什么要离职， 什么情况下你会毫不犹豫地辞职？浏览数已经达到51826523次了，5000w+，o_o！ 关键字：成长、发展、委屈、领导、钱（工资）突发感想是不是可以抓取下然后分析关键字，哈哈哈 还有 「宁愿花 11K 重新招人，也不愿意花 9K 留住老员工」的现象是否属实？为什么会出现该现象？ 还想看吗 离职前一定要找好下家吗？公司招聘时一般如何看待裸辞和骑驴找马？ 我的理解：面试不是高考，高考只有一次（不说补习），面试可以有n次，只要有面试机会，你就可以一直去面，面到吐为止都没关系，不要怕失败，公司没选择你不是你不优秀，而是你不符合他们的要求，回家思考下面试不足的地方，调整下心态，准备下个面试才是你正确的做法。 二、面试准备准备是多方面的，俗话说：成功只留给有准备的人 1. 问：什么时候开始准备？你是牛人吗 ? 不用准备，等猎头挖 : 老老实实的随时准备好 2. 问：怎么准备？ 项目经验是一部分：面试是离不开的，充分理解自己所做的那部分，能在面试中清楚的表述出自己做了什么，充当什么样的角色 自己分享知识的地方：比如博客/github，自己总结的会比去看别人的总结效果好不只一丁半点 基础知识：字符串操作、数组操作、文件操作、正则操作 进阶知识：面向对象、数据结构和算法、设计模式、mysql索引、mysql引擎、mysql事务、mysql锁 高阶知识：linux+nginx+mysql+php+redis 优化，只会操作没用，谁都会，高并发、分布式系统、负载均衡、分库分表、消息队列 三、面试干货1、某教育机构两面mysql事务是什么1234我说了mysql的四个特性，原子性、一致性、隔离性、持久性，事务可以理解成一次操作要不完成要不失败。面试官问了隔离性和锁的问题，有点忘了，这个真没答上来-------------可以参考下《Innodb中的事务隔离级别和锁的关系》https://tech.meituan.com/innodb-lock.html php代码解释过程123我说了通过zend引擎解析成opcode，然后转化成机器识别的代码。平时确实没有去关注这个，失败失败，查了资料鸟哥写的《深入理解PHP原理之Opcodes》http://www.laruence.com/2008/06/18/221.html 百度统计的实现原理123我没答上来，自己后面查的-------------参考：http://blog.csdn.net/iqzq123/article/details/8877645 如何共享session123我说了通过redis存储session，以达到共享目的，后面查了下方案，还挺多的-------------参考：http://www.cnblogs.com/wangtao_20/p/3395518.html#commentform git分支管理策略1234我写了master作为主分支，dev作为开发分支，bug_fix分支作为bug分支面试官说有个临时bug需要改，而我们在dev上已经开发了很多内容了，我答的是用bug_fix分支拉master代码，再合回去，面试官说dev怎么办，改了相同的模块会冲突想了下，确实会，然后求教面试官，面试官说可以用git rebase变基实现，自己见过这个命令，但是没用过，尴尬 restful设计123我说了get、post、put、patch、delete，面试官问他们分别怎么用，毕竟自己做api的就回答了get是从服务器取资源、post是新建资源、put是更新完整资源、patch更新部分资源、delete是删除资源，就过了 附加题：论坛的表设计12有点忘了，我答的不是很好，问的是有以下几个需求，请问需要建几张表，为什么？主要考的如何合理的设计表，比如用户登录信息表可以怎样设计？发帖表和回帖表需要怎样设计？内容字段比较大，怎样设计更好？哪些字段需要加索引？ 情景题：一个登录系统的改进12345678用伪代码实现第一步：PC端只有两个表单框和注册按钮，后端接收参数，再存入数据库第二步：添加移动端，需要发送短信第三步：加入第三方登陆方式，需要发送邮件第四步：有个兄弟公司，给了我们一张execl表，里面是用户信息，需要后台注册这些用户，如何修改现有的代码第四步：有点忘了，好像是如何进一步优化这里第三步就答不好了，考察的是逻辑能力和代码组织能力，设计模式的重要性。 自己最满意的代码1自己自由发挥，项目中遇到的应该是最好答的 了解哪些设计模式，实际用例1234567我的回答工厂模式：定义一个标准，用到的类可以按这个标准实现相应功能单例模式：防止重复实例化，减少资源调用数据映射：数据库ORM应用适配器模式：兼容老数据，多态的应用面试管问了怎么兼容老数据，考察codereview能力 困了，先到这里 2、某电商公司三人面笔试题挺有意思的，比较能考察出我这样的面试者水平 笔试题的解法见php7.php文件中的24、25、26 将一个二维数组的值首字母大写12题目意思大概是这样的，印象不深很清了当时做的时候好像做错了，现在想了下，思路是获取键值和值，然后双重循环转大写即可。 使用正则获取html里的href属性的值和a标签内的值，并以href值为key，a标签内的值为value存入二维数组中大概是这样的结构，我简化了 123456789&lt;ul class="attr"&gt; &lt;li&gt; &lt;a href="www.baidu.com"&gt;百度baidu&lt;/a&gt; &lt;a href='www.tecent.com'&gt;腾讯tengxun&lt;/a&gt; &lt;a href="www.alibaba.com"&gt;阿里巴巴alibaba&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt;考察正则表达式的运用和数组的拼装，我当时做的稀烂，回去稍微看了下正则，就很容易了。 优化语句查询test表中数据有500w，字段有id/t_id/type_id/plat_id，语句为select max(t_id) from test where type_id=1 and plat_id=1 1234567考察mysql语句优化，这里主要是优化max函数，max函数会导致全表扫描，效率会很低，可以使用order by加limit进行优化我是这样答的select t_id from test where type_id=1 and plat_id=1 order by t_id desc limit 1;当然还可以使用加索引进一步优化速度，这里可以加上(type_id/plat_id)联合索引。-------------正确做法是给`t_id`加索引，还有(type_id/plat_id)联合索引，order by 并不能避免全表扫描。 找出N个数中的第M大的数12考察算法，貌似是查找？我当时的想法是先对数组排序，然后索引的N-M的数就是M大的数 Ajax跨域请求时，会出现什么问题？如何解决1234我的回答：稀烂，跨域出现问题会出现请求拒绝，是出于安全起见，设置Access-Control-Allow-Origin为*即可。哈哈哈naive-------------回去搜了下，方案还挺多的。参考https://dailc.github.io/2017/03/22/ajaxCrossDomainSolution.html 如何优化一个CPU运算密集的网站1没有实践过对吧，没关系，会google吗？会背吗？脑子能留个大概的原理吗？ 自己最满意的 代码1自己自由发挥，项目中遇到的应该是最好答的 其它简历上的项目询问，项目中最有难度的地方？如何解决的？ 困了，睡 3、某民宿杭州分公司一面没有笔试题，纯面试题，很注重基础，比如操作系统 phpunit的用法12345自己平时没注意这个东西，所以答的稀烂，问到有没有连数据库测，我说有，只是用预期数据与数据库查出的数据对比测试面试官问有没有用过mock懵逼了，这个概念确实听过，没去做过，意思是造假的意思，通过模拟数据库操作来达到测试目的，还有stub站桩，需要多实践啊骚年 o_o-------------参考：https://phpunit.de/manual/current/zh_cn/test-doubles.html redis异步队列实现细节看我简历中写用过 1234我当时用的是laravel中的队列机制，通过dispatch()触发任务，php artisan queue:work 开启后台进程监视队列并完成任务面试官不满足，问我他的原理，怎样实现的？我说用的是list，通过触发lpush入队，然后依次rpop出队处理任务面试官说这是阻塞的，能不能有高效的做法，我说不清楚，面试官好像说可以把一个list的数据放到多个list中并行处理，zzz。 redis中zest如何根据两个属性排序，比如id和age12345不知道，只知道根据score分值排序，有知道的同学可以留言请自行google redis zset 多字段排序-------------查了下，有说先自行排序后存入redishttps://segmentfault.com/q/1010000004669705 你对多进程和多线程还有协程的理解作为cs专业的phper，大学学的都交给老师了，zzz 123456789进程可以有多个线程，在php中yield可以实现协程，面试官问swoole新版本中自带协程，你怎么理解？没研究过zzz-------------进程是正在运行的程序的实例进程是内核分配资源的最基本的单元线程是内核执行的最基本的单元进程内可以包含多个线程协程的话相当于语言自己实现一个函数调度参考：http://www.cnblogs.com/lxmhhy/p/6041001.html 说说怎么理解现在前端框架中的组件化和模块化看到我会react.js问的 123我说就比如react里的组件可以理解为一个class类，模块的意思是一个文件就是一个模块，有单独的作用域-------------参考：http://xiaodongtongxue.top/2016/05/20/浅谈前端自动化%20工程化%20组件化%20模块化/ http协议中get和post的区别，怎么实现的123456get是获取资源，post创建资源get数据长度有限制，post无限制get数据在url中安全性差,post不显示在url中更安全怎么实现的，懵逼zzz-------------参考：https://zhuanlan.zhihu.com/p/22536382 最近在看什么书1送命题，没看过就老实说没看过好了，不然会xxxx，比如我说了看了《图解HTTP》，首先问了我上面那道题，然后说你看的书不够深入，我。。。。 4、某众筹杭州分公司三面php使用什么mysql连接？123456789101112还以为很简单呢，直接说了mysqli和pdo，mysql弃用了面试官来了句不是问这个，是问连接池我对这个概念很懵，就回了是持久连接吗，可以用mysql_connect()面试官再问比如laravel默认使用什么mysql连接的我猜的是pdo吧他说再想想我xxxx，就这样过了-------------回去很郁闷的查了下，默认PDO，我还以为是想考察关于php编译时mysqlnd这样的呢All database work in Laravel is done through the PHP PDO facilitiesso make sure you have the driver for your particular database ofchoice installed on your machine before you begin development. 场景题：索引的建立规则和explain有这样一张表 自增id、名字、昵称、年龄、客户类型、创建时间 哪些字段需要建立索引？为什么？ 1234我说年龄、创建时间、客户类型需要建立索引，where条件经常用到的字段面试官说客户类型用的enum枚举呢，是不是也需要建立索引我说不清楚面试官说其实是不需要的，枚举类型只有几种，mysql查询时会分组查，一般写sql前可以用explain观察sql语句 你用的是php版本是哪个？为什么？php7有什么更新？1234567很幸运，自己一直用的是php7，因为php7速度有很大提升，也有很多新特性，比如标量类型声明、返回类型声明命名空间、Trait、自动加载都是现代php所需要的面试官问有自己发不过composer包吗？他的自动加载原理是怎么样的？自己创建过composer包，没发布，自动加载是通过sql_autoload_register()实现的面试官说之前都是include引入的对吧，你应该在往前想下我xxxx面试官说是当这个文件使用的时候，才会加载进来，以达到自动加载目的。 nginx相关简历写了了解nginx负载均衡和反向代理，你是怎么做的 php-fpm能代理其他端口吗？除了默认9000 nginx配置php-fpm的时候走的是什么协议？还可以走其他协议吗？ 123自己搭建的vps，负载均衡是通过多个端口实现的，反向代理是代理到apache可以走其他端口，需要配置ini文件，走的http协议，其它协议，不知道面试官说可以走tcp协议，比如socket 看你用过laravel和tp，比较下两款框架1234567tp是国人写的，理念比较陈旧过时laravel是现在最火的php框架，开源社区活跃，工具也最多，运用了面向对象的思想和很多设计模式，是值得学习和运用的选择laravel的源码看过吗？看过，laravel的container容器，还有ioc控制反转、di依赖注入，通过server provider服务提供者bind绑定实例放入到容器内，然后通过make解析容器中的某个实例，可以通过facade门面直接静态调用。面试官说怎么兼容之前的版本，比如像app那样，既发布了新的版本，老版本也需要兼容。我没做过，我的想法是一通过适配器模式，达到兼容两者的需求，二可以使用dingo/api多版本控制 你未来的发展规划，1年的，3年的1自由发挥，其实也蛮重要的，往积极方面答总没错，比如深入php、扩展技术栈 其他简历上的项目询问，项目中最有难度的地方？如何解决的？ 5、某旅游公司两面套路真多，这面试官很有代入感 为什么离职机智点，按你填表里写的离职理由答就行，别露馅了，哈哈哈。 如何选择PHP的？关于目前流行的Java比较？这里机智点答就行，比较的话讲两者的使用场景，比如php适合web开发，java有多种选择，web和安卓 有没有系统的培训过？有没有看php相关的网络课程和书籍？12我以为是说我有没有去培训过，我当然说没了我说的是慕课网的优秀课程和《Modern PHP》《PHP核心技术和最佳实践》《PHP the right way》 看你用过laravel和tp， 比较下两款框架12345tp是国人写的，理念比较陈旧过时laravel是现在最火的php框架，开源社区活跃，工具也最多，运用了面向对象的思想和很多设计模式，是值得学习和运用的选择laravel的源码看过吗？看过，laravel的container容器，还有ioc控制反转、di依赖注入，通过server provider服务提供者bind绑定实例放入到容器内，然后通过make解析容器中的某个实例，可以通过facade门面直接静态调用。 php基础知识**123456php面向对象说下封装、继承、多态多态描述下当时这里说成了重载了，真是扇自己一巴掌，其实多态是一套接口下面的实现类，注入的是接口类，使用的是实现类，从而实现多态php的类型有哪些还真的忘了，掌嘴，没说完整，说了array数组、string字符串、object对象、resource资源、NULL laravel包**12345dingo/api和jwt-auth是自己搭的吗？有没有遇到坑？当时项目赶，用的集成的，自己搭也是没问题的entrust怎么用的？有哪些表？user用户表、role角色表、perm权限表、role-user用户角色关联表、role-perm角色权限关联表我们还做了扩展，menu菜单表、menu-perm菜单权限关联表 你未来的发展规划， 1年的，3年的1自由发挥，其实也蛮重要的，往积极方面答总没错，比如深入php、扩展技术栈 你可以问我两个问题？1234当场黑人问号，为什么是两个问题？面试官：我想看你的关注点我说了这边技术团队是怎样的+有没有技术分享+我加入公司将做什么别问我为什么问了三个，因为我get到了面试官的点，哈哈哈 其 他1简历上的项目询问，为什么离职，之前收获了什么，你期待的公司是怎样的etc 1234为什么说套路呢，不然发现这个面试官所有准备的题都是有针对性的，后面他就指出我的基础不够扎实，并举例说一个基础扎实的人和一个基础不扎实的人做同一个东西，基础扎实的可能很快就会做完且不会出错，而不扎实的老是需要google且做出的东西会出错，也不知道哪里错了，因为是拿来主义并没有转为自己的东西。然后指出我没有系统学习过php，因为php容易入门，但是学会它需要花很大功夫。最后说我的规划还不错，是加分项，哈哈哈。 四、面试总结面了5家公司，拿了3份offer，自我感觉还良好吧，哈哈哈。最主要的还是心态、面试准备、面试总结、睡眠质量、水 写的挺流水化的，很多都有点遗忘，毕竟2星期后了，只能记住有意义的题目了。 有心的同学应该会看到我这个noteBook下面的其它知识，希望对你们有些许帮助。 后语：有收获的话请加颗小星星，没有收获的话可以 反对 没有帮助 举报三连 注明：本文转自Laravel-China、OMGZui。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP json_encode 空白问题]]></title>
    <url>%2F2018%2F01%2F25%2FPHP-json-encode-%E7%A9%BA%E7%99%BD%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[昨天在修改基于shopsn的项目的源码时遇到个GAY问题最后返回数据时 整个页面空白页 但是又不报错经过排查 定位到是json_encode的问题于是使用 json_last_error 函数 返回最后错误码 发现是 JSON_ERROR_INF_OR_NAN 于是查看 果然有个NAN参数 悄悄混了进去 于是做了处理 完美解决]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
</search>
